{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\nconst QUOTE = \"\\\"\";\nconst expectedKeywords = new Map([[\"t\", TRUE], [\"f\", FALSE], [\"n\", NULL]]);\nconst escapeToChar = new Map([[QUOTE, QUOTE], [\"\\\\\", \"\\\\\"], [\"/\", \"/\"], [\"b\", \"\\b\"], [\"n\", \"\\n\"], [\"f\", \"\\f\"], [\"r\", \"\\r\"], [\"t\", \"\\t\"]]);\nconst knownTokenTypes = new Map([[LBRACKET, \"Punctuator\"], [RBRACKET, \"Punctuator\"], [LBRACE, \"Punctuator\"], [RBRACE, \"Punctuator\"], [COLON, \"Punctuator\"], [COMMA, \"Punctuator\"], [TRUE, \"Boolean\"], [FALSE, \"Boolean\"], [NULL, \"Null\"]]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n  /**\n   * \n   * @param {string} message The error message to report. \n   * @param {int} loc.line The line on which the error occurred.\n   * @param {int} loc.column The column in the line where the error occurrred.\n   * @param {int} loc.index The index in the string where the error occurred.\n   */\n  constructor(message, {\n    line,\n    column,\n    index\n  }) {\n    super(`${message} (${line}:${column})`);\n\n    /**\n     * The line on which the error occurred.\n     * @type int\n     * @property line\n     */\n    this.line = line;\n\n    /**\n     * The column on which the error occurred.\n     * @type int\n     * @property column\n     */\n    this.column = column;\n\n    /**\n     * The index into the string where the error occurred.\n     * @type int\n     * @property index\n     */\n    this.index = index;\n  }\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n  /**\n   * Creates a new instance.\n   * @param {string} unexpected The character that was found.\n   * @param {Object} loc The location information for the found character.\n   */\n  constructor(unexpected, loc) {\n    super(`Unexpected character ${unexpected} found.`, loc);\n  }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n  /**\n   * Creates a new instance.\n   * @param {string} expected The character that was expected. \n   * @param {string} unexpected The character that was found.\n   * @param {Object} loc The location information for the found character.\n   */\n  constructor(token) {\n    super(`Unexpected token ${token.type}(${token.value}) found.`, token.loc.start);\n  }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n  /**\n   * Creates a new instance.\n   * @param {Object} loc The location information for the found character.\n   */\n  constructor(loc) {\n    super(\"Unexpected end of input found.\", loc);\n  }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\nconst DEFAULT_OPTIONS = {\n  comments: false,\n  ranges: false\n};\nfunction isWhitespace(c) {\n  return /[\\s\\n]/.test(c);\n}\nfunction isDigit(c) {\n  return c >= \"0\" && c <= \"9\";\n}\nfunction isHexDigit(c) {\n  return isDigit(c) || /[a-f]/i.test(c);\n}\nfunction isPositiveDigit(c) {\n  return c >= \"1\" && c <= \"9\";\n}\nfunction isKeywordStart(c) {\n  return /[tfn]/.test(c);\n}\nfunction isNumberStart(c) {\n  return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n  options = Object.freeze({\n    ...DEFAULT_OPTIONS,\n    ...options\n  });\n  let offset = -1;\n  let line = 1;\n  let column = 0;\n  let newLine = false;\n  const tokens = [];\n  function createToken(tokenType, value, startLoc, endLoc) {\n    const endOffset = startLoc.offset + value.length;\n    let range = options.ranges ? {\n      range: [startLoc.offset, endOffset]\n    } : undefined;\n    return {\n      type: tokenType,\n      value,\n      loc: {\n        start: startLoc,\n        end: endLoc || {\n          line: startLoc.line,\n          column: startLoc.column + value.length,\n          offset: endOffset\n        }\n      },\n      ...range\n    };\n  }\n  function next() {\n    let c = text.charAt(++offset);\n    if (newLine) {\n      line++;\n      column = 1;\n      newLine = false;\n    } else {\n      column++;\n    }\n    if (c === \"\\r\") {\n      newLine = true;\n\n      // if we already see a \\r, just ignore upcoming \\n\n      if (text.charAt(offset + 1) === \"\\n\") {\n        offset++;\n      }\n    } else if (c === \"\\n\") {\n      newLine = true;\n    }\n    return c;\n  }\n  function locate() {\n    return {\n      line,\n      column,\n      offset\n    };\n  }\n  function readKeyword(c) {\n    // get the expected keyword\n    let value = expectedKeywords.get(c);\n\n    // check to see if it actually exists\n    if (text.slice(offset, offset + value.length) === value) {\n      offset += value.length - 1;\n      column += value.length - 1;\n      return {\n        value,\n        c: next()\n      };\n    }\n\n    // find the first unexpected character\n    for (let j = 1; j < value.length; j++) {\n      if (value[j] !== text.charAt(offset + j)) {\n        unexpected(next());\n      }\n    }\n  }\n  function readString(c) {\n    let value = c;\n    c = next();\n    while (c && c !== QUOTE$1) {\n      // escapes\n      if (c === \"\\\\\") {\n        value += c;\n        c = next();\n        if (escapeToChar.has(c)) {\n          value += c;\n        } else if (c === \"u\") {\n          value += c;\n          for (let i = 0; i < 4; i++) {\n            c = next();\n            if (isHexDigit(c)) {\n              value += c;\n            } else {\n              unexpected(c);\n            }\n          }\n        } else {\n          unexpected(c);\n        }\n      } else {\n        value += c;\n      }\n      c = next();\n    }\n    if (!c) {\n      unexpectedEOF();\n    }\n    value += c;\n    return {\n      value,\n      c: next()\n    };\n  }\n  function readNumber(c) {\n    let value = \"\";\n\n    // Number may start with a minus but not a plus\n    if (c === \"-\") {\n      value += c;\n      c = next();\n\n      // Next digit cannot be zero\n      if (!isDigit(c)) {\n        unexpected(c);\n      }\n    }\n\n    // Zero must be followed by a decimal point or nothing\n    if (c === \"0\") {\n      value += c;\n      c = next();\n      if (isDigit(c)) {\n        unexpected(c);\n      }\n    } else {\n      if (!isPositiveDigit(c)) {\n        unexpected(c);\n      }\n      do {\n        value += c;\n        c = next();\n      } while (isDigit(c));\n    }\n\n    // Decimal point may be followed by any number of digits\n    if (c === \".\") {\n      do {\n        value += c;\n        c = next();\n      } while (isDigit(c));\n    }\n\n    // Exponent is always last\n    if (c === \"e\" || c === \"E\") {\n      value += c;\n      c = next();\n      if (c === \"+\" || c === \"-\") {\n        value += c;\n        c = next();\n      }\n\n      /*\n       * Must always have a digit in this position to avoid:\n       * 5e\n       * 12E+\n       * 42e-\n       */\n      if (!isDigit(c)) {\n        unexpected(c);\n      }\n      while (isDigit(c)) {\n        value += c;\n        c = next();\n      }\n    }\n    return {\n      value,\n      c\n    };\n  }\n\n  /**\n   * Reads in either a single-line or multi-line comment.\n   * @param {string} c The first character of the comment.\n   * @returns {string} The comment string.\n   * @throws {UnexpectedChar} when the comment cannot be read.\n   * @throws {UnexpectedEOF} when EOF is reached before the comment is\n   *      finalized.\n   */\n  function readComment(c) {\n    let value = c;\n\n    // next character determines single- or multi-line\n    c = next();\n\n    // single-line comments\n    if (c === \"/\") {\n      do {\n        value += c;\n        c = next();\n      } while (c && c !== \"\\r\" && c !== \"\\n\");\n      return {\n        value,\n        c\n      };\n    }\n\n    // multi-line comments\n    if (c === STAR) {\n      while (c) {\n        value += c;\n        c = next();\n\n        // check for end of comment\n        if (c === STAR) {\n          value += c;\n          c = next();\n\n          //end of comment\n          if (c === SLASH) {\n            value += c;\n\n            /*\n             * The single-line comment functionality cues up the\n             * next character, so we do the same here to avoid\n             * splitting logic later.\n             */\n            c = next();\n            return {\n              value,\n              c\n            };\n          }\n        }\n      }\n      unexpectedEOF();\n    }\n\n    // if we've made it here, there's an invalid character\n    unexpected(c);\n  }\n\n  /**\n   * Convenience function for throwing unexpected character errors.\n   * @param {string} c The unexpected character.\n   * @returns {void}\n   * @throws {UnexpectedChar} always.\n   */\n  function unexpected(c) {\n    throw new UnexpectedChar(c, locate());\n  }\n\n  /**\n   * Convenience function for throwing unexpected EOF errors.\n   * @returns {void}\n   * @throws {UnexpectedEOF} always.\n   */\n  function unexpectedEOF() {\n    throw new UnexpectedEOF(locate());\n  }\n  let c = next();\n  while (offset < text.length) {\n    while (isWhitespace(c)) {\n      c = next();\n    }\n    if (!c) {\n      break;\n    }\n    const start = locate();\n\n    // check for easy case\n    if (knownTokenTypes.has(c)) {\n      tokens.push(createToken(knownTokenTypes.get(c), c, start));\n      c = next();\n    } else if (isKeywordStart(c)) {\n      const result = readKeyword(c);\n      let value = result.value;\n      c = result.c;\n      tokens.push(createToken(knownTokenTypes.get(value), value, start));\n    } else if (isNumberStart(c)) {\n      const result = readNumber(c);\n      let value = result.value;\n      c = result.c;\n      tokens.push(createToken(\"Number\", value, start));\n    } else if (c === QUOTE$1) {\n      const result = readString(c);\n      let value = result.value;\n      c = result.c;\n      tokens.push(createToken(\"String\", value, start));\n    } else if (c === SLASH && options.comments) {\n      const result = readComment(c);\n      let value = result.value;\n      c = result.c;\n      tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n    } else {\n      unexpected(c);\n    }\n  }\n  return tokens;\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n  document(body, parts = {}) {\n    return {\n      type: \"Document\",\n      body,\n      ...parts\n    };\n  },\n  string(value, parts = {}) {\n    return {\n      type: \"String\",\n      value,\n      ...parts\n    };\n  },\n  number(value, parts = {}) {\n    return {\n      type: \"Number\",\n      value,\n      ...parts\n    };\n  },\n  boolean(value, parts = {}) {\n    return {\n      type: \"Boolean\",\n      value,\n      ...parts\n    };\n  },\n  null(parts = {}) {\n    return {\n      type: \"Null\",\n      value: \"null\",\n      ...parts\n    };\n  },\n  array(elements, parts = {}) {\n    return {\n      type: \"Array\",\n      elements,\n      ...parts\n    };\n  },\n  object(members, parts = {}) {\n    return {\n      type: \"Object\",\n      members,\n      ...parts\n    };\n  },\n  member(name, value, parts = {}) {\n    return {\n      type: \"Member\",\n      name,\n      value,\n      ...parts\n    };\n  }\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n  tokens: false,\n  comments: false,\n  ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n  // slice off the quotation marks\n  let value = token.value.slice(1, -1);\n  let result = \"\";\n  let escapeIndex = value.indexOf(\"\\\\\");\n  let lastIndex = 0;\n\n  // While there are escapes, interpret them to build up the result\n  while (escapeIndex >= 0) {\n    // append the text that happened before the escape\n    result += value.slice(lastIndex, escapeIndex);\n\n    // get the character immediately after the \\\n    const escapeChar = value.charAt(escapeIndex + 1);\n\n    // check for the non-Unicode escape sequences first\n    if (escapeToChar.has(escapeChar)) {\n      result += escapeToChar.get(escapeChar);\n      lastIndex = escapeIndex + 2;\n    } else if (escapeChar === \"u\") {\n      const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n      if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n        throw new ErrorWithLocation(`Invalid unicode escape \\\\u${hexCode}.`, {\n          line: token.loc.start.line,\n          column: token.loc.start.column + escapeIndex,\n          offset: token.loc.start.offset + escapeIndex\n        });\n      }\n      result += String.fromCharCode(parseInt(hexCode, 16));\n      lastIndex = escapeIndex + 6;\n    } else {\n      throw new ErrorWithLocation(`Invalid escape \\\\${escapeChar}.`, {\n        line: token.loc.start.line,\n        column: token.loc.start.column + escapeIndex,\n        offset: token.loc.start.offset + escapeIndex\n      });\n    }\n\n    // find the next escape sequence\n    escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n  }\n\n  // get the last segment of the string value\n  result += value.slice(lastIndex);\n  return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n  switch (token.type) {\n    case \"Boolean\":\n      return token.value === \"true\";\n    case \"Number\":\n      return Number(token.value);\n    case \"Null\":\n      return null;\n    case \"String\":\n      return getStringValue(token);\n  }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n  options = Object.freeze({\n    ...DEFAULT_OPTIONS$1,\n    ...options\n  });\n  const tokens = tokenize(text, {\n    comments: !!options.comments,\n    ranges: !!options.ranges\n  });\n  let tokenIndex = 0;\n  function nextNoComments() {\n    return tokens[tokenIndex++];\n  }\n  function nextSkipComments() {\n    const nextToken = tokens[tokenIndex++];\n    if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n      return nextSkipComments();\n    }\n    return nextToken;\n  }\n\n  // determine correct way to evaluate tokens based on presence of comments\n  const next = options.comments ? nextSkipComments : nextNoComments;\n  function assertTokenValue(token, value) {\n    if (!token || token.value !== value) {\n      throw new UnexpectedToken(token);\n    }\n  }\n  function assertTokenType(token, type) {\n    if (!token || token.type !== type) {\n      throw new UnexpectedToken(token);\n    }\n  }\n  function createRange(start, end) {\n    return options.ranges ? {\n      range: [start.offset, end.offset]\n    } : undefined;\n  }\n  function createLiteralNode(token) {\n    const range = createRange(token.loc.start, token.loc.end);\n    return {\n      type: token.type,\n      value: getLiteralValue(token),\n      loc: {\n        start: {\n          ...token.loc.start\n        },\n        end: {\n          ...token.loc.end\n        }\n      },\n      ...range\n    };\n  }\n  function parseProperty(token) {\n    assertTokenType(token, \"String\");\n    const name = createLiteralNode(token);\n    token = next();\n    assertTokenValue(token, \":\");\n    const value = parseValue();\n    const range = createRange(name.loc.start, value.loc.end);\n    return types.member(name, value, {\n      loc: {\n        start: {\n          ...name.loc.start\n        },\n        end: {\n          ...value.loc.end\n        }\n      },\n      ...range\n    });\n  }\n  function parseObject(firstToken) {\n    // The first token must be a { or else it's an error\n    assertTokenValue(firstToken, \"{\");\n    const members = [];\n    let token = next();\n    if (token && token.value !== \"}\") {\n      do {\n        // add the value into the array\n        members.push(parseProperty(token));\n        token = next();\n        if (token.value === \",\") {\n          token = next();\n        } else {\n          break;\n        }\n      } while (token);\n    }\n    assertTokenValue(token, \"}\");\n    const range = createRange(firstToken.loc.start, token.loc.end);\n    return types.object(members, {\n      loc: {\n        start: {\n          ...firstToken.loc.start\n        },\n        end: {\n          ...token.loc.end\n        }\n      },\n      ...range\n    });\n  }\n  function parseArray(firstToken) {\n    // The first token must be a [ or else it's an error\n    assertTokenValue(firstToken, \"[\");\n    const elements = [];\n    let token = next();\n    if (token && token.value !== \"]\") {\n      do {\n        // add the value into the array\n        elements.push(parseValue(token));\n        token = next();\n        if (token.value === \",\") {\n          token = next();\n        } else {\n          break;\n        }\n      } while (token);\n    }\n    assertTokenValue(token, \"]\");\n    const range = createRange(firstToken.loc.start, token.loc.end);\n    return types.array(elements, {\n      type: \"Array\",\n      elements,\n      loc: {\n        start: {\n          ...firstToken.loc.start\n        },\n        end: {\n          ...token.loc.end\n        }\n      },\n      ...range\n    });\n  }\n  function parseValue(token) {\n    token = token || next();\n    switch (token.type) {\n      case \"String\":\n      case \"Boolean\":\n      case \"Number\":\n      case \"Null\":\n        return createLiteralNode(token);\n      case \"Punctuator\":\n        if (token.value === \"{\") {\n          return parseObject(token);\n        } else if (token.value === \"[\") {\n          return parseArray(token);\n        }\n      /*falls through*/\n\n      default:\n        throw new UnexpectedToken(token);\n    }\n  }\n  const docBody = parseValue();\n  const unexpectedToken = next();\n  if (unexpectedToken) {\n    throw new UnexpectedToken(unexpectedToken);\n  }\n  const docParts = {\n    loc: {\n      start: {\n        line: 1,\n        column: 1,\n        offset: 0\n      },\n      end: {\n        ...docBody.loc.end\n      }\n    }\n  };\n  if (options.tokens) {\n    docParts.tokens = tokens;\n  }\n  if (options.ranges) {\n    docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n  }\n  return types.document(docBody, docParts);\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([[\"Document\", [\"body\"]], [\"Object\", [\"members\"]], [\"Member\", [\"name\", \"value\"]], [\"Array\", [\"elements\"]], [\"String\", []], [\"Number\", []], [\"Boolean\", []], [\"Null\", []]]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n  return value && typeof value === \"object\";\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n  return isObject(value) && typeof value.type === \"string\";\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n  /**\n   * Recursively visits a node.\n   * @param {Node} node The node to visit.\n   * @param {Node} parent The parent of the node to visit.\n   * @returns {void}\n   */\n  function visitNode(node, parent) {\n    if (typeof visitor.enter === \"function\") {\n      visitor.enter(node, parent);\n    }\n    for (const key of childKeys.get(node.type)) {\n      const value = node[key];\n      if (isObject(value)) {\n        if (Array.isArray(value)) {\n          value.forEach(child => visitNode(child, node));\n        } else if (isNode(value)) {\n          visitNode(value, node);\n        }\n      }\n    }\n    if (typeof visitor.exit === \"function\") {\n      visitor.exit(node, parent);\n    }\n  }\n  visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n  const traversal = [];\n  traverse(root, {\n    enter(node, parent) {\n      traversal.push({\n        node,\n        parent,\n        phase: \"enter\"\n      });\n    },\n    exit(node, parent) {\n      traversal.push({\n        node,\n        parent,\n        phase: \"exit\"\n      });\n    }\n  });\n  return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n  switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n      return node.value;\n    case \"Null\":\n      return null;\n    case \"Array\":\n      return node.elements.map(evaluate);\n    case \"Object\":\n      {\n        const object = {};\n        node.members.forEach(member => {\n          object[evaluate(member.name)] = evaluate(member.value);\n        });\n        return object;\n      }\n    case \"Document\":\n      return evaluate(node.body);\n    case \"Property\":\n      throw new Error(\"Cannot evaluate object property outside of an object.\");\n    default:\n      throw new Error(`Unknown node type ${node.type}.`);\n  }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, {\n  indent = 0\n} = {}) {\n  const value = evaluate(node);\n  return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;","map":{"version":3,"names":["Object","defineProperty","exports","value","LBRACKET","RBRACKET","LBRACE","RBRACE","COLON","COMMA","TRUE","FALSE","NULL","QUOTE","expectedKeywords","Map","escapeToChar","knownTokenTypes","ErrorWithLocation","Error","constructor","message","line","column","index","UnexpectedChar","unexpected","loc","UnexpectedToken","token","type","start","UnexpectedEOF","QUOTE$1","SLASH","STAR","DEFAULT_OPTIONS","comments","ranges","isWhitespace","c","test","isDigit","isHexDigit","isPositiveDigit","isKeywordStart","isNumberStart","tokenize","text","options","freeze","offset","newLine","tokens","createToken","tokenType","startLoc","endLoc","endOffset","length","range","undefined","end","next","charAt","locate","readKeyword","get","slice","j","readString","has","i","unexpectedEOF","readNumber","readComment","push","result","startsWith","types","document","body","parts","string","number","boolean","null","array","elements","object","members","member","name","DEFAULT_OPTIONS$1","getStringValue","escapeIndex","indexOf","lastIndex","escapeChar","hexCode","String","fromCharCode","parseInt","getLiteralValue","Number","parse","tokenIndex","nextNoComments","nextSkipComments","nextToken","endsWith","assertTokenValue","assertTokenType","createRange","createLiteralNode","parseProperty","parseValue","parseObject","firstToken","parseArray","docBody","unexpectedToken","docParts","childKeys","isObject","isNode","traverse","root","visitor","visitNode","node","parent","enter","key","Array","isArray","forEach","child","exit","iterator","filter","traversal","phase","values","evaluate","map","print","indent","JSON","stringify"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/@humanwhocodes/momoa/api.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            /*\n             * Must always have a digit in this position to avoid:\n             * 5e\n             * 12E+\n             * 42e-\n             */\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.value !== \"}\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.value === \",\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.value !== \"]\") {\n\n            do {\n\n              // add the value into the array\n              elements.push(parseValue(token));\n\n              token = next();\n              \n              if (token.value === \",\") {\n                  token = next();\n              } else {\n                  break;\n              }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}