{"ast":null,"code":"const {\n  openapi\n} = require('@apidevtools/openapi-schemas');\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst betterAjvErrors = require('@readme/better-ajv-errors');\nconst Ajv = require('ajv/dist/2020');\nconst AjvDraft4 = require('ajv-draft-04');\nconst {\n  getSpecificationName\n} = require('../util');\n\n/**\n * We've had issues with specs larger than 2MB+ with 1,000+ errors causing memory leaks so if we\n * have a spec with more than `LARGE_SPEC_ERROR_CAP` errors and it's **stringified** length is\n * larger than `LARGE_SPEC_LIMITS` then we will only return the first `LARGE_SPEC_ERROR_CAP` errors.\n *\n * Ideally we'd be looking at the byte size of the spec instead of looking at its stringified\n * length value but the Blob API, which we'd use to get its size with `new Blob([str]).size;`, was\n * only recently introduced in Node 15.\n *\n * w/r/t the 5,000,000 limit here: The spec we found causing these memory leaks had a size of\n * 13,934,323 so 5mil seems like a decent cap to start with.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob}\n */\nconst LARGE_SPEC_ERROR_CAP = 20;\nconst LARGE_SPEC_SIZE_CAP = 5000000;\nmodule.exports = validateSchema;\n\n/**\n * Validates the given Swagger API against the Swagger 2.0 or OpenAPI 3.0 and 3.1 schemas.\n *\n * @param {SwaggerObject} api\n * @param {Object} options\n */\nfunction validateSchema(api, options) {\n  let ajv;\n\n  // Choose the appropriate schema (Swagger or OpenAPI)\n  let schema;\n  if (api.swagger) {\n    schema = openapi.v2;\n    ajv = initializeAjv();\n  } else if (api.openapi.startsWith('3.1')) {\n    schema = openapi.v31;\n\n    // There's a bug with Ajv in how it handles `$dynamicRef` in the way that it's used within the 3.1 schema so we\n    // need to do some adhoc workarounds.\n    // https://github.com/OAI/OpenAPI-Specification/issues/2689\n    // https://github.com/ajv-validator/ajv/issues/1573\n    const schemaDynamicRef = schema.$defs.schema;\n    delete schemaDynamicRef.$dynamicAnchor;\n    schema.$defs.components.properties.schemas.additionalProperties = schemaDynamicRef;\n    schema.$defs.header.dependentSchemas.schema.properties.schema = schemaDynamicRef;\n    schema.$defs['media-type'].properties.schema = schemaDynamicRef;\n    schema.$defs.parameter.properties.schema = schemaDynamicRef;\n    ajv = initializeAjv(false);\n  } else {\n    schema = openapi.v3;\n    ajv = initializeAjv();\n  }\n\n  // Validate against the schema\n  const isValid = ajv.validate(schema, api);\n  if (!isValid) {\n    const err = ajv.errors;\n    let additionalErrors = 0;\n    let reducedErrors = reduceAjvErrors(err);\n    if (reducedErrors.length >= LARGE_SPEC_ERROR_CAP) {\n      try {\n        if (JSON.stringify(api).length >= LARGE_SPEC_SIZE_CAP) {\n          additionalErrors = reducedErrors.length - 20;\n          reducedErrors = reducedErrors.slice(0, 20);\n        }\n      } catch (err) {\n        // If we failed to stringify the API definition to look at its size then we should process\n        // all of its errors as-is.\n      }\n    }\n    let message = `${getSpecificationName(api)} schema validation failed.\\n`;\n    message += '\\n';\n    message += betterAjvErrors(schema, api, reducedErrors, {\n      colorize: options.validate.colorizeErrors,\n      indent: 2\n    });\n    if (additionalErrors) {\n      message += '\\n\\n';\n      message += `Plus an additional ${additionalErrors} errors. Please resolve the above and re-run validation to see more.`;\n    }\n    throw ono.syntax(err, {\n      details: err\n    }, message);\n  }\n}\n\n/**\n * Determines which version of Ajv to load and prepares it for use.\n *\n * @param {bool} draft04\n * @returns {Ajv}\n */\nfunction initializeAjv(draft04 = true) {\n  const opts = {\n    allErrors: true,\n    strict: false,\n    validateFormats: false\n  };\n  if (draft04) {\n    return new AjvDraft4(opts);\n  }\n  return new Ajv(opts);\n}\n\n/**\n * Because of the way that Ajv works, if a validation error occurs deep within a schema there's a chance that errors\n * will also be thrown for its immediate parents, leading to a case where we'll eventually show the error indecipherable\n * errors like \"$ref is missing here!\" instance of what's _actually_ going on where they may have mistyped `enum` as\n * `enumm`.\n *\n * To alleviate this confusing noise, we're compressing Ajv errors down to only surface the deepest point for each\n * lineage, so that if a user typos `enum` as `enumm` we'll surface just that error for them (because really that's\n * **the** error).\n *\n * @param {Array} errors\n * @returns {Array}\n */\nfunction reduceAjvErrors(errors) {\n  const flattened = new Map();\n  errors.forEach(err => {\n    // These two errors appear when a child schema of them has a problem and instead of polluting the user with\n    // indecipherable noise we should instead relay the more specific error to them. If this is all that's present in\n    // the stack then as a safety net before we wrap up we'll just return the original `errors` stack.\n    if ([\"must have required property '$ref'\", 'must match exactly one schema in oneOf'].includes(err.message)) {\n      return;\n    }\n\n    // If this is our first run through let's initialize our dataset and move along.\n    if (!flattened.size) {\n      flattened.set(err.instancePath, err);\n      return;\n    } else if (flattened.has(err.instancePath)) {\n      // If we already have an error recorded for this `instancePath` we can ignore it because we (likely) already have\n      // recorded the more specific error.\n      return;\n    }\n\n    // If this error hasn't already been recorded, maybe it's an error against the same `instancePath` stack, in which\n    // case we should ignore it because the more specific error has already been recorded.\n    let shouldRecordError = true;\n    flattened.forEach(flat => {\n      if (flat.instancePath.includes(err.instancePath)) {\n        shouldRecordError = false;\n      }\n    });\n    if (shouldRecordError) {\n      flattened.set(err.instancePath, err);\n    }\n  });\n\n  // If we weren't able to fold errors down for whatever reason just return the original stack.\n  if (!flattened.size) {\n    return errors;\n  }\n  return [...flattened.values()];\n}","map":{"version":3,"names":["openapi","require","ono","betterAjvErrors","Ajv","AjvDraft4","getSpecificationName","LARGE_SPEC_ERROR_CAP","LARGE_SPEC_SIZE_CAP","module","exports","validateSchema","api","options","ajv","schema","swagger","v2","initializeAjv","startsWith","v31","schemaDynamicRef","$defs","$dynamicAnchor","components","properties","schemas","additionalProperties","header","dependentSchemas","parameter","v3","isValid","validate","err","errors","additionalErrors","reducedErrors","reduceAjvErrors","length","JSON","stringify","slice","message","colorize","colorizeErrors","indent","syntax","details","draft04","opts","allErrors","strict","validateFormats","flattened","Map","forEach","includes","size","set","instancePath","has","shouldRecordError","flat","values"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/@readme/openapi-parser/lib/validators/schema.js"],"sourcesContent":["const { openapi } = require('@apidevtools/openapi-schemas');\nconst { ono } = require('@jsdevtools/ono');\nconst betterAjvErrors = require('@readme/better-ajv-errors');\nconst Ajv = require('ajv/dist/2020');\nconst AjvDraft4 = require('ajv-draft-04');\n\nconst { getSpecificationName } = require('../util');\n\n/**\n * We've had issues with specs larger than 2MB+ with 1,000+ errors causing memory leaks so if we\n * have a spec with more than `LARGE_SPEC_ERROR_CAP` errors and it's **stringified** length is\n * larger than `LARGE_SPEC_LIMITS` then we will only return the first `LARGE_SPEC_ERROR_CAP` errors.\n *\n * Ideally we'd be looking at the byte size of the spec instead of looking at its stringified\n * length value but the Blob API, which we'd use to get its size with `new Blob([str]).size;`, was\n * only recently introduced in Node 15.\n *\n * w/r/t the 5,000,000 limit here: The spec we found causing these memory leaks had a size of\n * 13,934,323 so 5mil seems like a decent cap to start with.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob}\n */\nconst LARGE_SPEC_ERROR_CAP = 20;\nconst LARGE_SPEC_SIZE_CAP = 5000000;\n\nmodule.exports = validateSchema;\n\n/**\n * Validates the given Swagger API against the Swagger 2.0 or OpenAPI 3.0 and 3.1 schemas.\n *\n * @param {SwaggerObject} api\n * @param {Object} options\n */\nfunction validateSchema(api, options) {\n  let ajv;\n\n  // Choose the appropriate schema (Swagger or OpenAPI)\n  let schema;\n\n  if (api.swagger) {\n    schema = openapi.v2;\n    ajv = initializeAjv();\n  } else if (api.openapi.startsWith('3.1')) {\n    schema = openapi.v31;\n\n    // There's a bug with Ajv in how it handles `$dynamicRef` in the way that it's used within the 3.1 schema so we\n    // need to do some adhoc workarounds.\n    // https://github.com/OAI/OpenAPI-Specification/issues/2689\n    // https://github.com/ajv-validator/ajv/issues/1573\n    const schemaDynamicRef = schema.$defs.schema;\n    delete schemaDynamicRef.$dynamicAnchor;\n\n    schema.$defs.components.properties.schemas.additionalProperties = schemaDynamicRef;\n    schema.$defs.header.dependentSchemas.schema.properties.schema = schemaDynamicRef;\n    schema.$defs['media-type'].properties.schema = schemaDynamicRef;\n    schema.$defs.parameter.properties.schema = schemaDynamicRef;\n\n    ajv = initializeAjv(false);\n  } else {\n    schema = openapi.v3;\n    ajv = initializeAjv();\n  }\n\n  // Validate against the schema\n  const isValid = ajv.validate(schema, api);\n  if (!isValid) {\n    const err = ajv.errors;\n\n    let additionalErrors = 0;\n    let reducedErrors = reduceAjvErrors(err);\n    if (reducedErrors.length >= LARGE_SPEC_ERROR_CAP) {\n      try {\n        if (JSON.stringify(api).length >= LARGE_SPEC_SIZE_CAP) {\n          additionalErrors = reducedErrors.length - 20;\n          reducedErrors = reducedErrors.slice(0, 20);\n        }\n      } catch (err) {\n        // If we failed to stringify the API definition to look at its size then we should process\n        // all of its errors as-is.\n      }\n    }\n\n    let message = `${getSpecificationName(api)} schema validation failed.\\n`;\n    message += '\\n';\n    message += betterAjvErrors(schema, api, reducedErrors, {\n      colorize: options.validate.colorizeErrors,\n      indent: 2,\n    });\n\n    if (additionalErrors) {\n      message += '\\n\\n';\n      message += `Plus an additional ${additionalErrors} errors. Please resolve the above and re-run validation to see more.`;\n    }\n\n    throw ono.syntax(err, { details: err }, message);\n  }\n}\n\n/**\n * Determines which version of Ajv to load and prepares it for use.\n *\n * @param {bool} draft04\n * @returns {Ajv}\n */\nfunction initializeAjv(draft04 = true) {\n  const opts = {\n    allErrors: true,\n    strict: false,\n    validateFormats: false,\n  };\n\n  if (draft04) {\n    return new AjvDraft4(opts);\n  }\n\n  return new Ajv(opts);\n}\n\n/**\n * Because of the way that Ajv works, if a validation error occurs deep within a schema there's a chance that errors\n * will also be thrown for its immediate parents, leading to a case where we'll eventually show the error indecipherable\n * errors like \"$ref is missing here!\" instance of what's _actually_ going on where they may have mistyped `enum` as\n * `enumm`.\n *\n * To alleviate this confusing noise, we're compressing Ajv errors down to only surface the deepest point for each\n * lineage, so that if a user typos `enum` as `enumm` we'll surface just that error for them (because really that's\n * **the** error).\n *\n * @param {Array} errors\n * @returns {Array}\n */\nfunction reduceAjvErrors(errors) {\n  const flattened = new Map();\n\n  errors.forEach(err => {\n    // These two errors appear when a child schema of them has a problem and instead of polluting the user with\n    // indecipherable noise we should instead relay the more specific error to them. If this is all that's present in\n    // the stack then as a safety net before we wrap up we'll just return the original `errors` stack.\n    if ([\"must have required property '$ref'\", 'must match exactly one schema in oneOf'].includes(err.message)) {\n      return;\n    }\n\n    // If this is our first run through let's initialize our dataset and move along.\n    if (!flattened.size) {\n      flattened.set(err.instancePath, err);\n      return;\n    } else if (flattened.has(err.instancePath)) {\n      // If we already have an error recorded for this `instancePath` we can ignore it because we (likely) already have\n      // recorded the more specific error.\n      return;\n    }\n\n    // If this error hasn't already been recorded, maybe it's an error against the same `instancePath` stack, in which\n    // case we should ignore it because the more specific error has already been recorded.\n    let shouldRecordError = true;\n    flattened.forEach(flat => {\n      if (flat.instancePath.includes(err.instancePath)) {\n        shouldRecordError = false;\n      }\n    });\n\n    if (shouldRecordError) {\n      flattened.set(err.instancePath, err);\n    }\n  });\n\n  // If we weren't able to fold errors down for whatever reason just return the original stack.\n  if (!flattened.size) {\n    return errors;\n  }\n\n  return [...flattened.values()];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}