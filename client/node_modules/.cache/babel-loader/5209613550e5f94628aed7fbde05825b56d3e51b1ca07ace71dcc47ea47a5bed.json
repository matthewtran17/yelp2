{"ast":null,"code":"const swaggerMethods = require('@apidevtools/swagger-methods');\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst util = require('../../util');\nconst primitiveTypes = ['array', 'boolean', 'integer', 'number', 'string'];\nconst schemaTypes = ['array', 'boolean', 'integer', 'number', 'string', 'object', 'null', undefined];\nmodule.exports = validateSpec;\n\n/**\n * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.\n *\n * @param {SwaggerObject} api\n */\nfunction validateSpec(api) {\n  const operationIds = [];\n  Object.keys(api.paths || {}).forEach(pathName => {\n    const path = api.paths[pathName];\n    const pathId = `/paths${pathName}`;\n    if (path && pathName.indexOf('/') === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  });\n  Object.keys(api.definitions || {}).forEach(definitionName => {\n    const definition = api.definitions[definitionName];\n    const definitionId = `/definitions/${definitionName}`;\n    if (!/^[a-zA-Z0-9.\\-_]+$/.test(definitionName)) {\n      throw ono.syntax(`Validation failed. ${definitionId} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`);\n    }\n    validateRequiredPropertiesExist(definition, definitionId);\n  });\n}\n\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\nfunction validatePath(api, path, pathId, operationIds) {\n  swaggerMethods.forEach(operationName => {\n    const operation = path[operationName];\n    const operationId = `${pathId}/${operationName}`;\n    if (operation) {\n      const declaredOperationId = operation.operationId;\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        } else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n      validateParameters(api, path, pathId, operation, operationId);\n      Object.keys(operation.responses || {}).forEach(responseName => {\n        const response = operation.responses[responseName];\n        const responseId = `${operationId}/responses/${responseName}`;\n        validateResponse(responseName, response || {}, responseId);\n      });\n    }\n  });\n}\n\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\nfunction validateParameters(api, path, pathId, operation, operationId) {\n  const pathParams = path.parameters || [];\n  const operationParams = operation.parameters || [];\n\n  // Check for duplicate path parameters\n  try {\n    checkForDuplicates(pathParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  }\n\n  // Check for duplicate operation parameters\n  try {\n    checkForDuplicates(operationParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  }\n\n  // Combine the path and operation parameters,\n  // with the operation params taking precedence over the path params\n  const params = pathParams.reduce((combinedParams, value) => {\n    const duplicate = combinedParams.some(param => {\n      return param.in === value.in && param.name === value.name;\n    });\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n    return combinedParams;\n  }, operationParams.slice());\n  validateBodyParameters(params, operationId);\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n\n/**\n * Validates body and formData parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateBodyParameters(params, operationId) {\n  const bodyParams = params.filter(param => {\n    return param.in === 'body';\n  });\n  const formParams = params.filter(param => {\n    return param.in === 'formData';\n  });\n\n  // There can only be one \"body\" parameter\n  if (bodyParams.length > 1) {\n    throw ono.syntax(`Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`);\n  } else if (bodyParams.length > 0 && formParams.length > 0) {\n    // \"body\" params and \"formData\" params are mutually exclusive\n    throw ono.syntax(`Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`);\n  }\n}\n\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\nfunction validatePathParameters(params, pathId, operationId) {\n  // Find all {placeholders} in the path string\n  const placeholders = pathId.match(util.swaggerParamRegExp) || [];\n\n  // Check for duplicates\n  for (let i = 0; i < placeholders.length; i++) {\n    for (let j = i + 1; j < placeholders.length; j++) {\n      if (placeholders[i] === placeholders[j]) {\n        throw ono.syntax(`Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);\n      }\n    }\n  }\n  params.filter(param => param.in === 'path').forEach(param => {\n    if (param.required !== true) {\n      throw ono.syntax('Validation failed. Path parameters cannot be optional. ' + `Set required=true for the \"${param.name}\" parameter at ${operationId}`);\n    }\n    const match = placeholders.indexOf(`{${param.name}}`);\n    if (match === -1) {\n      throw ono.syntax(`Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` + `but there is no corresponding {${param.name}} in the path string`);\n    }\n    placeholders.splice(match, 1);\n  });\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateParameterTypes(params, api, operation, operationId) {\n  params.forEach(param => {\n    const parameterId = `${operationId}/parameters/${param.name}`;\n    let schema;\n    let validTypes;\n    switch (param.in) {\n      case 'body':\n        schema = param.schema;\n        validTypes = schemaTypes;\n        break;\n      case 'formData':\n        schema = param;\n        validTypes = primitiveTypes.concat('file');\n        break;\n      default:\n        schema = param;\n        validTypes = primitiveTypes;\n    }\n    validateSchema(schema, parameterId, validTypes);\n    validateRequiredPropertiesExist(schema, parameterId);\n    if (schema.type === 'file') {\n      // \"file\" params must consume at least one of these MIME types\n      const formData = /multipart\\/(.*\\+)?form-data/; // eslint-disable-line unicorn/no-unsafe-regex\n      const urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/; // eslint-disable-line unicorn/no-unsafe-regex\n\n      const consumes = operation.consumes || api.consumes || [];\n      const hasValidMimeType = consumes.some(consume => {\n        return formData.test(consume) || urlEncoded.test(consume);\n      });\n      if (!hasValidMimeType) {\n        throw ono.syntax(`Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` + 'or application/x-www-form-urlencoded');\n      }\n    }\n  });\n}\n\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\nfunction checkForDuplicates(params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    const outer = params[i];\n    for (let j = i + 1; j < params.length; j++) {\n      const inner = params[j];\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\nfunction validateResponse(code, response, responseId) {\n  if (code !== 'default' && (code < 100 || code > 599)) {\n    throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);\n  }\n  Object.keys(response.headers || {}).forEach(headerName => {\n    const header = response.headers[headerName];\n    const headerId = `${responseId}/headers/${headerName}`;\n    validateSchema(header, headerId, primitiveTypes);\n  });\n  if (response.schema) {\n    const validTypes = schemaTypes.concat('file');\n    if (validTypes.indexOf(response.schema.type) === -1) {\n      throw ono.syntax(`Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`);\n    } else {\n      validateSchema(response.schema, `${responseId}/schema`, validTypes);\n    }\n  }\n}\n\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n * @param {string[]}  validTypes  - An array of the allowed schema types\n */\nfunction validateSchema(schema, schemaId, validTypes) {\n  if (validTypes.indexOf(schema.type) === -1) {\n    throw ono.syntax(`Validation failed. ${schemaId} has an invalid type (${schema.type})`);\n  }\n  if (schema.type === 'array' && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}\n\n/**\n * Validates that the declared properties of the given Swagger schema object actually exist.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\nfunction validateRequiredPropertiesExist(schema, schemaId) {\n  // Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n  function collectProperties(schemaObj, props) {\n    if (schemaObj.properties) {\n      Object.keys(schemaObj.properties).forEach(property => {\n        // eslint-disable-next-line no-prototype-builtins\n        if (schemaObj.properties.hasOwnProperty(property)) {\n          // eslint-disable-next-line no-param-reassign\n          props[property] = schemaObj.properties[property];\n        }\n      });\n    }\n    if (schemaObj.allOf) {\n      schemaObj.allOf.forEach(parent => {\n        collectProperties(parent, props);\n      });\n    }\n  }\n  if (schema.required && Array.isArray(schema.required)) {\n    const props = {};\n    collectProperties(schema, props);\n    schema.required.forEach(requiredProperty => {\n      if (!props[requiredProperty]) {\n        throw ono.syntax(`Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`);\n      }\n    });\n  }\n}","map":{"version":3,"names":["swaggerMethods","require","ono","util","primitiveTypes","schemaTypes","undefined","module","exports","validateSpec","api","operationIds","Object","keys","paths","forEach","pathName","path","pathId","indexOf","validatePath","definitions","definitionName","definition","definitionId","test","syntax","validateRequiredPropertiesExist","operationName","operation","operationId","declaredOperationId","push","validateParameters","responses","responseName","response","responseId","validateResponse","pathParams","parameters","operationParams","checkForDuplicates","e","params","reduce","combinedParams","value","duplicate","some","param","in","name","slice","validateBodyParameters","validatePathParameters","validateParameterTypes","bodyParams","filter","formParams","length","placeholders","match","swaggerParamRegExp","i","j","required","splice","parameterId","schema","validTypes","concat","validateSchema","type","formData","urlEncoded","consumes","hasValidMimeType","consume","outer","inner","code","headers","headerName","header","headerId","schemaId","items","collectProperties","schemaObj","props","properties","property","hasOwnProperty","allOf","parent","Array","isArray","requiredProperty"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/@readme/openapi-parser/lib/validators/spec/swagger.js"],"sourcesContent":["const swaggerMethods = require('@apidevtools/swagger-methods');\nconst { ono } = require('@jsdevtools/ono');\n\nconst util = require('../../util');\n\nconst primitiveTypes = ['array', 'boolean', 'integer', 'number', 'string'];\nconst schemaTypes = ['array', 'boolean', 'integer', 'number', 'string', 'object', 'null', undefined];\n\nmodule.exports = validateSpec;\n\n/**\n * Validates parts of the Swagger 2.0 spec that aren't covered by the Swagger 2.0 JSON Schema.\n *\n * @param {SwaggerObject} api\n */\nfunction validateSpec(api) {\n  const operationIds = [];\n  Object.keys(api.paths || {}).forEach(pathName => {\n    const path = api.paths[pathName];\n    const pathId = `/paths${pathName}`;\n\n    if (path && pathName.indexOf('/') === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  });\n\n  Object.keys(api.definitions || {}).forEach(definitionName => {\n    const definition = api.definitions[definitionName];\n    const definitionId = `/definitions/${definitionName}`;\n\n    if (!/^[a-zA-Z0-9.\\-_]+$/.test(definitionName)) {\n      throw ono.syntax(\n        `Validation failed. ${definitionId} has an invalid name. Definition names should match against: /^[a-zA-Z0-9.-_]+$/`\n      );\n    }\n\n    validateRequiredPropertiesExist(definition, definitionId);\n  });\n}\n\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\nfunction validatePath(api, path, pathId, operationIds) {\n  swaggerMethods.forEach(operationName => {\n    const operation = path[operationName];\n    const operationId = `${pathId}/${operationName}`;\n\n    if (operation) {\n      const declaredOperationId = operation.operationId;\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        } else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n      validateParameters(api, path, pathId, operation, operationId);\n\n      Object.keys(operation.responses || {}).forEach(responseName => {\n        const response = operation.responses[responseName];\n        const responseId = `${operationId}/responses/${responseName}`;\n        validateResponse(responseName, response || {}, responseId);\n      });\n    }\n  });\n}\n\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\nfunction validateParameters(api, path, pathId, operation, operationId) {\n  const pathParams = path.parameters || [];\n  const operationParams = operation.parameters || [];\n\n  // Check for duplicate path parameters\n  try {\n    checkForDuplicates(pathParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  }\n\n  // Check for duplicate operation parameters\n  try {\n    checkForDuplicates(operationParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  }\n\n  // Combine the path and operation parameters,\n  // with the operation params taking precedence over the path params\n  const params = pathParams.reduce((combinedParams, value) => {\n    const duplicate = combinedParams.some(param => {\n      return param.in === value.in && param.name === value.name;\n    });\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n    return combinedParams;\n  }, operationParams.slice());\n\n  validateBodyParameters(params, operationId);\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n\n/**\n * Validates body and formData parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateBodyParameters(params, operationId) {\n  const bodyParams = params.filter(param => {\n    return param.in === 'body';\n  });\n  const formParams = params.filter(param => {\n    return param.in === 'formData';\n  });\n\n  // There can only be one \"body\" parameter\n  if (bodyParams.length > 1) {\n    throw ono.syntax(\n      `Validation failed. ${operationId} has ${bodyParams.length} body parameters. Only one is allowed.`\n    );\n  } else if (bodyParams.length > 0 && formParams.length > 0) {\n    // \"body\" params and \"formData\" params are mutually exclusive\n    throw ono.syntax(\n      `Validation failed. ${operationId} has body parameters and formData parameters. Only one or the other is allowed.`\n    );\n  }\n}\n\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\nfunction validatePathParameters(params, pathId, operationId) {\n  // Find all {placeholders} in the path string\n  const placeholders = pathId.match(util.swaggerParamRegExp) || [];\n\n  // Check for duplicates\n  for (let i = 0; i < placeholders.length; i++) {\n    for (let j = i + 1; j < placeholders.length; j++) {\n      if (placeholders[i] === placeholders[j]) {\n        throw ono.syntax(`Validation failed. ${operationId} has multiple path placeholders named ${placeholders[i]}`);\n      }\n    }\n  }\n\n  params\n    .filter(param => param.in === 'path')\n    .forEach(param => {\n      if (param.required !== true) {\n        throw ono.syntax(\n          'Validation failed. Path parameters cannot be optional. ' +\n            `Set required=true for the \"${param.name}\" parameter at ${operationId}`\n        );\n      }\n\n      const match = placeholders.indexOf(`{${param.name}}`);\n      if (match === -1) {\n        throw ono.syntax(\n          `Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` +\n            `but there is no corresponding {${param.name}} in the path string`\n        );\n      }\n\n      placeholders.splice(match, 1);\n    });\n\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateParameterTypes(params, api, operation, operationId) {\n  params.forEach(param => {\n    const parameterId = `${operationId}/parameters/${param.name}`;\n    let schema;\n    let validTypes;\n\n    switch (param.in) {\n      case 'body':\n        schema = param.schema;\n        validTypes = schemaTypes;\n        break;\n      case 'formData':\n        schema = param;\n        validTypes = primitiveTypes.concat('file');\n        break;\n      default:\n        schema = param;\n        validTypes = primitiveTypes;\n    }\n\n    validateSchema(schema, parameterId, validTypes);\n    validateRequiredPropertiesExist(schema, parameterId);\n\n    if (schema.type === 'file') {\n      // \"file\" params must consume at least one of these MIME types\n      const formData = /multipart\\/(.*\\+)?form-data/; // eslint-disable-line unicorn/no-unsafe-regex\n      const urlEncoded = /application\\/(.*\\+)?x-www-form-urlencoded/; // eslint-disable-line unicorn/no-unsafe-regex\n\n      const consumes = operation.consumes || api.consumes || [];\n\n      const hasValidMimeType = consumes.some(consume => {\n        return formData.test(consume) || urlEncoded.test(consume);\n      });\n\n      if (!hasValidMimeType) {\n        throw ono.syntax(\n          `Validation failed. ${operationId} has a file parameter, so it must consume multipart/form-data ` +\n            'or application/x-www-form-urlencoded'\n        );\n      }\n    }\n  });\n}\n\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\nfunction checkForDuplicates(params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    const outer = params[i];\n    for (let j = i + 1; j < params.length; j++) {\n      const inner = params[j];\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\nfunction validateResponse(code, response, responseId) {\n  if (code !== 'default' && (code < 100 || code > 599)) {\n    throw ono.syntax(`Validation failed. ${responseId} has an invalid response code (${code})`);\n  }\n\n  Object.keys(response.headers || {}).forEach(headerName => {\n    const header = response.headers[headerName];\n    const headerId = `${responseId}/headers/${headerName}`;\n    validateSchema(header, headerId, primitiveTypes);\n  });\n\n  if (response.schema) {\n    const validTypes = schemaTypes.concat('file');\n    if (validTypes.indexOf(response.schema.type) === -1) {\n      throw ono.syntax(\n        `Validation failed. ${responseId} has an invalid response schema type (${response.schema.type})`\n      );\n    } else {\n      validateSchema(response.schema, `${responseId}/schema`, validTypes);\n    }\n  }\n}\n\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n * @param {string[]}  validTypes  - An array of the allowed schema types\n */\nfunction validateSchema(schema, schemaId, validTypes) {\n  if (validTypes.indexOf(schema.type) === -1) {\n    throw ono.syntax(`Validation failed. ${schemaId} has an invalid type (${schema.type})`);\n  }\n\n  if (schema.type === 'array' && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}\n\n/**\n * Validates that the declared properties of the given Swagger schema object actually exist.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\nfunction validateRequiredPropertiesExist(schema, schemaId) {\n  // Recursively collects all properties of the schema and its ancestors. They are added to the props object.\n  function collectProperties(schemaObj, props) {\n    if (schemaObj.properties) {\n      Object.keys(schemaObj.properties).forEach(property => {\n        // eslint-disable-next-line no-prototype-builtins\n        if (schemaObj.properties.hasOwnProperty(property)) {\n          // eslint-disable-next-line no-param-reassign\n          props[property] = schemaObj.properties[property];\n        }\n      });\n    }\n\n    if (schemaObj.allOf) {\n      schemaObj.allOf.forEach(parent => {\n        collectProperties(parent, props);\n      });\n    }\n  }\n\n  if (schema.required && Array.isArray(schema.required)) {\n    const props = {};\n    collectProperties(schema, props);\n    schema.required.forEach(requiredProperty => {\n      if (!props[requiredProperty]) {\n        throw ono.syntax(\n          `Validation failed. Property '${requiredProperty}' listed as required but does not exist in '${schemaId}'`\n        );\n      }\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}