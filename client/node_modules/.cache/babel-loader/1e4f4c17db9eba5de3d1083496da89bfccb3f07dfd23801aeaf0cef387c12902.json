{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaVersionString = void 0;\nvar json_schema_merge_allof_1 = __importDefault(require(\"json-schema-merge-allof\"));\nvar jsonpointer_1 = __importDefault(require(\"jsonpointer\"));\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar RMOAS = __importStar(require(\"../rmoas.types\"));\nvar helpers_1 = require(\"./helpers\");\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/main/src/consts.ts}\n */\nvar UNSUPPORTED_SCHEMA_PROPS = ['example', 'externalDocs', 'xml'];\n/**\n * List partially sourced from `openapi-schema-to-json-schema`.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/lib/converters/schema.js#L140-L154}\n */\nvar FORMAT_OPTIONS = {\n  INT8_MIN: 0 - Math.pow(2, 7),\n  INT8_MAX: Math.pow(2, 7) - 1,\n  INT16_MIN: 0 - Math.pow(2, 15),\n  INT16_MAX: Math.pow(2, 15) - 1,\n  INT32_MIN: 0 - Math.pow(2, 31),\n  INT32_MAX: Math.pow(2, 31) - 1,\n  INT64_MIN: 0 - Math.pow(2, 63),\n  INT64_MAX: Math.pow(2, 63) - 1,\n  UINT8_MIN: 0,\n  UINT8_MAX: Math.pow(2, 8) - 1,\n  UINT16_MIN: 0,\n  UINT16_MAX: Math.pow(2, 16) - 1,\n  UINT32_MIN: 0,\n  UINT32_MAX: Math.pow(2, 32) - 1,\n  UINT64_MIN: 0,\n  UINT64_MAX: Math.pow(2, 64) - 1,\n  FLOAT_MIN: 0 - Math.pow(2, 128),\n  FLOAT_MAX: Math.pow(2, 128) - 1,\n  DOUBLE_MIN: 0 - Number.MAX_VALUE,\n  DOUBLE_MAX: Number.MAX_VALUE\n};\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str) {\n  return str.replace('~', '~0').replace('/', '~1');\n}\nfunction getSchemaVersionString(schema, api) {\n  // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n  if (!RMOAS.isOAS31(api)) {\n    // This should remain as an HTTP url, not HTTPS.\n    return 'http://json-schema.org/draft-04/schema#';\n  }\n  /**\n   * If the schema indicates the version, prefer that.\n   *\n   * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n   * above.\n   */\n  if (schema.$schema) {\n    return schema.$schema;\n  }\n  // If the user defined a global schema version on their OAS document, prefer that.\n  if (api.jsonSchemaDialect) {\n    return api.jsonSchemaDialect;\n  }\n  return 'https://json-schema.org/draft/2020-12/schema#';\n}\nexports.getSchemaVersionString = getSchemaVersionString;\nfunction isPolymorphicSchema(schema) {\n  return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\nfunction isRequestBodySchema(schema) {\n  return 'content' in schema;\n}\n/**\n * Given a JSON pointer, a type of property to look for, and an array of schemas do a reverse\n * search through them until we find the JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param property Specific type of schema property to look for a value for.\n * @param pointer JSON pointer to search for an example for.\n * @param schemas Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForValueByPropAndPointer(property, pointer, schemas) {\n  if (schemas === void 0) {\n    schemas = [];\n  }\n  if (!schemas.length || !pointer.length) {\n    return undefined;\n  }\n  var locSplit = pointer.split('/').filter(Boolean).reverse();\n  var pointers = [];\n  var point = '';\n  for (var i = 0; i < locSplit.length; i += 1) {\n    point = \"/\".concat(locSplit[i]).concat(point);\n    pointers.push(point);\n  }\n  var foundValue;\n  var rev = __spreadArray([], schemas, true).reverse();\n  for (var i = 0; i < pointers.length; i += 1) {\n    for (var ii = 0; ii < rev.length; ii += 1) {\n      var schema = rev[ii];\n      if (property === 'example') {\n        if ('example' in schema) {\n          schema = schema.example;\n        } else {\n          if (!Array.isArray(schema.examples) || !schema.examples.length) {\n            continue;\n          }\n          // Prevent us from crashing if `examples` is a completely empty object.\n          schema = __spreadArray([], schema.examples, true).shift();\n        }\n      } else {\n        schema = schema.default;\n      }\n      try {\n        foundValue = jsonpointer_1.default.get(schema, pointers[i]);\n      } catch (err) {\n        // If the schema we're looking at is `{obj: null}` and our pointer is `/obj/propertyName`\n        // `jsonpointer` will throw an error. If that happens, we should silently catch and toss it\n        // and return no example.\n      }\n      if (foundValue !== undefined) {\n        break;\n      }\n    }\n    if (foundValue !== undefined) {\n      break;\n    }\n  }\n  return foundValue;\n}\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schemaObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nfunction toJSONSchema(data, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var schema = data === true ? {} : __assign({}, data);\n  var schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n  var _a = __assign({\n      addEnumsToDescriptions: false,\n      currentLocation: '',\n      globalDefaults: {},\n      hideReadOnlyProperties: false,\n      hideWriteOnlyProperties: false,\n      isPolymorphicAllOfChild: false,\n      prevDefaultSchemas: [],\n      prevExampleSchemas: [],\n      refLogger: function () {\n        return true;\n      },\n      transformer: function (s) {\n        return s;\n      }\n    }, opts),\n    addEnumsToDescriptions = _a.addEnumsToDescriptions,\n    currentLocation = _a.currentLocation,\n    globalDefaults = _a.globalDefaults,\n    hideReadOnlyProperties = _a.hideReadOnlyProperties,\n    hideWriteOnlyProperties = _a.hideWriteOnlyProperties,\n    isPolymorphicAllOfChild = _a.isPolymorphicAllOfChild,\n    prevDefaultSchemas = _a.prevDefaultSchemas,\n    prevExampleSchemas = _a.prevExampleSchemas,\n    refLogger = _a.refLogger,\n    transformer = _a.transformer;\n  // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n  // return and move along.\n  if (RMOAS.isRef(schema)) {\n    refLogger(schema.$ref, 'ref');\n    return transformer({\n      $ref: schema.$ref\n    });\n  }\n  // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n  // representation let's run through them and make sure they're good.\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n    // the tooling that ingests these schemas.\n    if ('allOf' in schema && Array.isArray(schema.allOf)) {\n      try {\n        schema = (0, json_schema_merge_allof_1.default)(schema, {\n          ignoreAdditionalProperties: true,\n          resolvers: {\n            // `merge-json-schema-allof` by default takes the first `description` when you're\n            // merging an `allOf` but because generally when you're merging two schemas together\n            // with an `allOf` you want data in the subsequent schemas to be applied to the first\n            // and `description` should be a part of that.\n            description: function (obj) {\n              return obj.slice(-1)[0];\n            },\n            // `merge-json-schema-allof` doesn't support merging enum arrays but since that's a\n            // safe and simple operation as enums always contain primitives we can handle it\n            // ourselves with a custom resolver.\n            enum: function (obj) {\n              var arr = [];\n              obj.forEach(function (e) {\n                arr = arr.concat(e);\n              });\n              return arr;\n            },\n            // JSON Schema ony supports examples with the `examples` property, since we're\n            // ingesting OpenAPI definitions we need to add a custom resolver for its `example`\n            // property.\n            example: function (obj) {\n              return obj[0];\n            },\n            // JSON Schema has no support for `format` on anything other than `string`, but since\n            // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we\n            // can still merge schemas that may have those.\n            format: function (obj) {\n              return obj[0];\n            },\n            // Since JSON Schema obviously doesn't know about our vendor extension we need to tell\n            // the library to essentially ignore and pass it along.\n            'x-readme-ref-name': function (obj) {\n              return obj[0];\n            }\n          }\n        });\n      } catch (e) {\n        // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n        // the other is a `object`) then we should completely remove it from the schema and continue\n        // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n        // to account for the incompatible `allOf` and it may be subject to more breakages than\n        // just not having it present would be.\n        var schemaWithoutAllOf = __rest(schema, []);\n        schema = schemaWithoutAllOf;\n        delete schema.allOf;\n      }\n      // If after merging the `allOf` this schema still contains a `$ref` then it's circular and\n      // we shouldn't do anything else.\n      if (RMOAS.isRef(schema)) {\n        refLogger(schema.$ref, 'ref');\n        return transformer({\n          $ref: schema.$ref\n        });\n      }\n    }\n    ['anyOf', 'oneOf'].forEach(function (polyType) {\n      if (polyType in schema && Array.isArray(schema[polyType])) {\n        schema[polyType].forEach(function (item, idx) {\n          var polyOptions = {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: \"\".concat(currentLocation, \"/\").concat(idx),\n            globalDefaults: globalDefaults,\n            hideReadOnlyProperties: hideReadOnlyProperties,\n            hideWriteOnlyProperties: hideWriteOnlyProperties,\n            isPolymorphicAllOfChild: false,\n            prevDefaultSchemas: prevDefaultSchemas,\n            prevExampleSchemas: prevExampleSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          };\n          // When `properties` or `items` are present alongside a polymorphic schema instead of\n          // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n          // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n          // `properties` + the polymorph schema.\n          //\n          // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n          if ('properties' in schema) {\n            schema[polyType][idx] = toJSONSchema({\n              allOf: [item, {\n                properties: schema.properties\n              }]\n            }, polyOptions);\n          } else if ('items' in schema) {\n            schema[polyType][idx] = toJSONSchema({\n              allOf: [item, {\n                items: schema.items\n              }]\n            }, polyOptions);\n          } else {\n            schema[polyType][idx] = toJSONSchema(item, polyOptions);\n          }\n          // Ensure that we don't have any invalid `required` booleans lying around.\n          if ((0, helpers_1.isObject)(schema[polyType][idx]) && 'required' in schema[polyType][idx] && typeof schema[polyType][idx].required === 'boolean') {\n            delete schema[polyType][idx].required;\n          }\n        });\n      }\n    });\n    if ('discriminator' in schema) {\n      if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n        // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n        // them to the supplied `refLogger`.\n        var mapping_1 = schema.discriminator.mapping;\n        Object.keys(mapping_1).forEach(function (k) {\n          refLogger(mapping_1[k], 'discriminator');\n        });\n      }\n    }\n  }\n  // If this schema is malformed for some reason, let's do our best to repair it.\n  if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n    if ('properties' in schema) {\n      schema.type = 'object';\n    } else if ('items' in schema) {\n      schema.type = 'array';\n    } else {\n      // If there's still no `type` on the schema we should leave it alone because we don't have a\n      // great way to know if it's part of a nested schema that should, and couldn't be merged,\n      // into another, or it's just purely malformed.\n      //\n      // Whatever tooling that ingests the generated schema should handle it however it needs to.\n    }\n  }\n  if ('type' in schema) {\n    // `nullable` isn't a thing in JSON Schema but it was in OpenAPI 3.0 so we should retain and\n    // translate it into something that's compatible with JSON Schema.\n    if ('nullable' in schema) {\n      if (Array.isArray(schema.type)) {\n        schema.type.push('null');\n      } else if (schema.type !== null && schema.type !== 'null') {\n        schema.type = [schema.type, 'null'];\n      }\n      delete schema.nullable;\n    }\n    if (schema.type === null) {\n      // `type: null` is possible in JSON Schema but we're translating it to a string version\n      // so we don't need to worry about asserting nullish types in our implementations of this\n      // generated schema.\n      schema.type = 'null';\n    } else if (Array.isArray(schema.type)) {\n      if (schema.type.includes(null)) {\n        schema.type[schema.type.indexOf(null)] = 'null';\n      }\n      schema.type = Array.from(new Set(schema.type));\n      // We don't need `type: [<type>]` when we can just as easily make it `type: <type>`.\n      if (schema.type.length === 1) {\n        schema.type = schema.type.shift();\n      } else if (schema.type.includes('array') || schema.type.includes('boolean') || schema.type.includes('object')) {\n        // If we have a `null` type but there's only two types present then we can remove `null`\n        // as an option and flag the whole schema as `nullable`.\n        var isNullable_1 = schema.type.includes('null');\n        if (schema.type.length === 2 && isNullable_1) {\n          // If this is `array | null` or `object | null` then we don't need to do anything.\n        } else {\n          // If this mixed type has non-primitives then we for convenience of our implementation\n          // we're moving them into a `oneOf`.\n          var nonPrimitives_1 = [];\n          // Because arrays, booleans, and objects are not compatible with any other schem type\n          // other than null we're moving them into an isolated `oneOf`, and as such want to take\n          // with it its specific properties that may be present on our current schema.\n          Object.entries({\n            // https://json-schema.org/understanding-json-schema/reference/array.html\n            array: ['additionalItems', 'contains', 'items', 'maxContains', 'maxItems', 'minContains', 'minItems', 'prefixItems', 'uniqueItems'],\n            // https://json-schema.org/understanding-json-schema/reference/boolean.html\n            boolean: [\n              // Booleans don't have any boolean-specific properties.\n            ],\n            // https://json-schema.org/understanding-json-schema/reference/object.html\n            object: ['additionalProperties', 'maxProperties', 'minProperties', 'nullable', 'patternProperties', 'properties', 'propertyNames', 'required']\n          }).forEach(function (_a) {\n            var _b, _c, _d, _e, _f, _g;\n            var typeKey = _a[0],\n              keywords = _a[1];\n            if (!schema.type.includes(typeKey)) {\n              return;\n            }\n            var reducedSchema = (0, remove_undefined_objects_1.default)({\n              type: isNullable_1 ? [typeKey, 'null'] : typeKey,\n              allowEmptyValue: (_b = schema.allowEmptyValue) !== null && _b !== void 0 ? _b : undefined,\n              deprecated: (_c = schema.deprecated) !== null && _c !== void 0 ? _c : undefined,\n              description: (_d = schema.description) !== null && _d !== void 0 ? _d : undefined,\n              readOnly: (_e = schema.readOnly) !== null && _e !== void 0 ? _e : undefined,\n              title: (_f = schema.title) !== null && _f !== void 0 ? _f : undefined,\n              writeOnly: (_g = schema.writeOnly) !== null && _g !== void 0 ? _g : undefined\n            });\n            keywords.forEach(function (t) {\n              if (t in schema) {\n                reducedSchema[t] = schema[t];\n                delete schema[t];\n              }\n            });\n            nonPrimitives_1.push(reducedSchema);\n          });\n          schema.type = schema.type.filter(function (t) {\n            return t !== 'array' && t !== 'boolean' && t !== 'object';\n          });\n          if (schema.type.length === 1) {\n            schema.type = schema.type.shift();\n          }\n          // Because we may have encountered a fully mixed non-primitive type like `array | object`\n          // we only want to retain the existing schema object if we still have types remaining\n          // in it.\n          if (schema.type.length > 1) {\n            schema = {\n              oneOf: __spreadArray([schema], nonPrimitives_1, true)\n            };\n          } else {\n            schema = {\n              oneOf: nonPrimitives_1\n            };\n          }\n        }\n      }\n    }\n  }\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n    if ('default' in schema && (0, helpers_1.isObject)(schema.default)) {\n      prevDefaultSchemas.push({\n        default: schema.default\n      });\n    }\n    // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n    if ('example' in schema) {\n      // Only bother adding primitive examples.\n      if ((0, helpers_1.isPrimitive)(schema.example)) {\n        schema.examples = [schema.example];\n      } else if (Array.isArray(schema.example)) {\n        schema.examples = schema.example.filter(function (example) {\n          return (0, helpers_1.isPrimitive)(example);\n        });\n        if (!schema.examples.length) {\n          delete schema.examples;\n        }\n      } else {\n        prevExampleSchemas.push({\n          example: schema.example\n        });\n      }\n      delete schema.example;\n    } else if ('examples' in schema) {\n      var reshapedExamples_1 = false;\n      if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n        var examples_1 = [];\n        Object.keys(schema.examples).forEach(function (name) {\n          var example = schema.examples[name];\n          if ('$ref' in example) {\n            // no-op because any `$ref` example here after dereferencing is circular so we should\n            // ignore it\n            refLogger(example.$ref, 'ref');\n          } else if ('value' in example) {\n            if ((0, helpers_1.isPrimitive)(example.value)) {\n              examples_1.push(example.value);\n              reshapedExamples_1 = true;\n            } else if (Array.isArray(example.value) && (0, helpers_1.isPrimitive)(example.value[0])) {\n              examples_1.push(example.value[0]);\n              reshapedExamples_1 = true;\n            } else {\n              // If this example is neither a primitive or an array we should dump it into the\n              // `prevExampleSchemas` array because we might be able to extract an example from it\n              // further downstream.\n              prevExampleSchemas.push({\n                example: example.value\n              });\n            }\n          }\n        });\n        if (examples_1.length) {\n          reshapedExamples_1 = true;\n          schema.examples = examples_1;\n        }\n      } else if (Array.isArray(schema.examples) && (0, helpers_1.isPrimitive)(schema.examples[0])) {\n        // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n        // let's keep it around.\n        reshapedExamples_1 = true;\n      }\n      if (!reshapedExamples_1) {\n        delete schema.examples;\n      }\n    }\n    // If we didn't have any immediately defined examples, let's search backwards and see if we can\n    // find one. But as we're only looking for primitive example, only try to search for one if\n    // we're dealing with a primitive schema.\n    if (!(0, helpers_1.hasSchemaType)(schema, 'array') && !(0, helpers_1.hasSchemaType)(schema, 'object') && !schema.examples) {\n      var foundExample = searchForValueByPropAndPointer('example', currentLocation, prevExampleSchemas);\n      if (foundExample) {\n        // We can only really deal with primitives, so only promote those as the found example if\n        // it is.\n        if ((0, helpers_1.isPrimitive)(foundExample) || Array.isArray(foundExample) && (0, helpers_1.isPrimitive)(foundExample[0])) {\n          schema.examples = [foundExample];\n        }\n      }\n    }\n    if ((0, helpers_1.hasSchemaType)(schema, 'array')) {\n      if ('items' in schema) {\n        if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n          // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n          // and ignore it.\n          refLogger(schema.items.$ref, 'ref');\n        } else if (schema.items !== true) {\n          // Run through the arrays contents and clean them up.\n          schema.items = toJSONSchema(schema.items, {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: \"\".concat(currentLocation, \"/0\"),\n            globalDefaults: globalDefaults,\n            hideReadOnlyProperties: hideReadOnlyProperties,\n            hideWriteOnlyProperties: hideWriteOnlyProperties,\n            prevExampleSchemas: prevExampleSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          });\n          // If we have a non-array `required` entry in our `items` schema then it's invalid and we\n          // should remove it. We only support non-array boolean `required` properties inside object\n          // properties.\n          if ((0, helpers_1.isObject)(schema.items) && 'required' in schema.items && !Array.isArray(schema.items.required)) {\n            delete schema.items.required;\n          }\n        }\n      } else if ('properties' in schema || 'additionalProperties' in schema) {\n        // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n        // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n        // type to be `object`, so we can do our best to shape the data into what they were\n        // intending it to be.\n        schema.type = 'object';\n      } else {\n        // This is a fix to handle cases where we have a malformed array with no `items` property\n        // present.\n        schema.items = {};\n      }\n    } else if ((0, helpers_1.hasSchemaType)(schema, 'object')) {\n      if ('properties' in schema) {\n        Object.keys(schema.properties).forEach(function (prop) {\n          if (Array.isArray(schema.properties[prop]) || typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null) {\n            var newPropSchema = toJSONSchema(schema.properties[prop], {\n              addEnumsToDescriptions: addEnumsToDescriptions,\n              currentLocation: \"\".concat(currentLocation, \"/\").concat(encodePointer(prop)),\n              globalDefaults: globalDefaults,\n              hideReadOnlyProperties: hideReadOnlyProperties,\n              hideWriteOnlyProperties: hideWriteOnlyProperties,\n              prevDefaultSchemas: prevDefaultSchemas,\n              prevExampleSchemas: prevExampleSchemas,\n              refLogger: refLogger,\n              transformer: transformer\n            });\n            // If this property is read or write only then we should fully hide it from its parent schema.\n            var propShouldBeUpdated = true;\n            if ((hideReadOnlyProperties || hideWriteOnlyProperties) && !Object.keys(newPropSchema).length) {\n              // We should only delete this schema if it wasn't already empty though. We do this\n              // because we (un)fortunately have handling in our API Explorer form system for\n              // schemas that are devoid of any `type` declaration.\n              if (Object.keys(schema.properties[prop]).length > 0) {\n                delete schema.properties[prop];\n                propShouldBeUpdated = false;\n              }\n            }\n            if (propShouldBeUpdated) {\n              schema.properties[prop] = newPropSchema;\n              /**\n               * JSON Schema does not have any support for `required: <boolean>` but because some\n               * of our users do this, and it does not throw OpenAPI validation errors thanks to\n               * some extremely loose typings around `schema` in the official JSON Schema\n               * definitions that the OAI offers, we're opting to support these users and upgrade\n               * their invalid `required` definitions into ones that our tooling can interpret.\n               *\n               * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/schemas/v3.1/schema.json#L1114-L1121}\n               */\n              if ((0, helpers_1.isObject)(newPropSchema) && 'required' in newPropSchema && typeof newPropSchema.required === 'boolean' && newPropSchema.required === true) {\n                if ('required' in schema && Array.isArray(schema.required)) {\n                  schema.required.push(prop);\n                } else {\n                  schema.required = [prop];\n                }\n                delete schema.properties[prop].required;\n              }\n            }\n          }\n        });\n        // If we want to hide all readOnly or writeOnly properites and it happens to be that this\n        // object was comprised of only those then we shouldn't render this object.\n        if (hideReadOnlyProperties || hideWriteOnlyProperties) {\n          if (!Object.keys(schema.properties).length) {\n            return transformer({});\n          }\n        }\n      }\n      if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n        // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n        // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n        if (!('type' in schemaAdditionalProperties) && !('$ref' in schemaAdditionalProperties) &&\n        // We know it will be a schema object because it's dereferenced\n        !isPolymorphicSchema(schemaAdditionalProperties)) {\n          schema.additionalProperties = true;\n        } else {\n          // We know it will be a schema object because it's dereferenced\n          schema.additionalProperties = toJSONSchema(schemaAdditionalProperties, {\n            addEnumsToDescriptions: addEnumsToDescriptions,\n            currentLocation: currentLocation,\n            globalDefaults: globalDefaults,\n            hideReadOnlyProperties: hideReadOnlyProperties,\n            hideWriteOnlyProperties: hideWriteOnlyProperties,\n            prevDefaultSchemas: prevDefaultSchemas,\n            prevExampleSchemas: prevExampleSchemas,\n            refLogger: refLogger,\n            transformer: transformer\n          });\n        }\n      }\n      // Since neither `properties` and `additionalProperties` are actually required to be present\n      // on an object, since we construct this schema work to build up a form we still need\n      // *something* for the user to enter in for this object so we'll add back in\n      // `additionalProperties` for that.\n      if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n        schema.additionalProperties = true;\n      }\n    }\n  }\n  // Ensure that number schemas formats have properly constrained min/max attributes according to\n  // whatever type of `format` and `type` they adhere to.\n  if ('format' in schema) {\n    var formatUpper = schema.format.toUpperCase();\n    if (\"\".concat(formatUpper, \"_MIN\") in FORMAT_OPTIONS) {\n      if (!schema.minimum && schema.minimum !== 0 || schema.minimum < FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")]) {\n        schema.minimum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")];\n      }\n    }\n    if (\"\".concat(formatUpper, \"_MAX\") in FORMAT_OPTIONS) {\n      if (!schema.maximum && schema.maximum !== 0 || schema.maximum > FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")]) {\n        schema.maximum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")];\n      }\n    }\n  }\n  /**\n   * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n   * being passed in exist on endpoints via jsonpointer\n   *\n   * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n   */\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && globalDefaults && Object.keys(globalDefaults).length > 0 && currentLocation) {\n    try {\n      var userJwtDefault = jsonpointer_1.default.get(globalDefaults, currentLocation);\n      if (userJwtDefault) {\n        schema.default = userJwtDefault;\n      }\n    } catch (err) {\n      // If jsonpointer returns an error, we won't show any defaults for that path.\n    }\n  }\n  // Only add a default value if we actually have one.\n  if ('default' in schema && typeof schema.default !== 'undefined') {\n    if ((0, helpers_1.hasSchemaType)(schema, 'object')) {\n      // Defaults for `object` and types have been dereferenced into their children schemas already\n      // above so we don't need to preserve this default anymore.\n      delete schema.default;\n    } else {\n      // If it's an enum and not the response schema, add the default to the description.\n      // If there's an existing description, trim trailing new lines so it doesn't look ugly.\n      if ('enum' in schema && !addEnumsToDescriptions) {\n        schema.description = schema.description ? \"\".concat(schema.description.replace(/\\n$/, ''), \"\\n\\nDefault: `\").concat(schema.default, \"`\") : \"Default: \".concat(schema.default);\n      }\n      if ('allowEmptyValue' in schema && schema.allowEmptyValue && schema.default === '' || schema.default !== '') {\n        // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n        // through as it's allowed.\n      } else {\n        // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n        // default.\n        delete schema.default;\n      }\n    }\n  } else if (prevDefaultSchemas.length) {\n    var foundDefault = searchForValueByPropAndPointer('default', currentLocation, prevDefaultSchemas);\n    // We shouldn't ever set an object default out of the parent lineage tree defaults because\n    // the contents of that object will be set on the schema that they're a part of. Setting\n    // that object as well would result us in duplicating the defaults for that schema in two\n    // places.\n    if ((0, helpers_1.isPrimitive)(foundDefault) || foundDefault === null || Array.isArray(foundDefault) && (0, helpers_1.hasSchemaType)(schema, 'array')) {\n      schema.default = foundDefault;\n    }\n  }\n  if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema.enum)) {\n    // Enums should not have duplicated items as those will break AJV validation.\n    // If we ever target ES6 for typescript we can drop this array.from.\n    // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n    schema.enum = Array.from(new Set(schema.enum));\n    // If we want to add enums to descriptions (like in the case of response JSON Schema)\n    // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n    // filtering away empty and falsy strings here because adding empty `` blocks to the description\n    // will serve nobody any good.\n    if (addEnumsToDescriptions) {\n      var enums = schema.enum.filter(Boolean).map(function (str) {\n        return \"`\".concat(str, \"`\");\n      }).join(' ');\n      if (enums.length) {\n        if ('description' in schema) {\n          schema.description += \"\\n\\n\".concat(enums);\n        } else {\n          schema.description = enums;\n        }\n      }\n    }\n  }\n  // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n  // polymorphism present.\n  if ('anyOf' in schema || 'oneOf' in schema) {\n    if ('properties' in schema) {\n      delete schema.properties;\n    }\n    if ('items' in schema) {\n      delete schema.items;\n    }\n  }\n  // Remove unsupported JSON Schema props.\n  for (var i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n    // Using the as here because the purpose is to delete keys we don't expect, so of course the\n    // typing won't work\n    delete schema[UNSUPPORTED_SCHEMA_PROPS[i]];\n  }\n  // If we want to hide any `readOnly` or `writeOnly` schemas, and this one is that, then we\n  // shouldn't return anything.\n  if (hideReadOnlyProperties && 'readOnly' in schema && schema.readOnly === true) {\n    return {};\n  } else if (hideWriteOnlyProperties && 'writeOnly' in schema && schema.writeOnly === true) {\n    return {};\n  }\n  return transformer(schema);\n}\nexports.default = toJSONSchema;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__createBinding","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__spreadArray","to","from","pack","l","ar","Array","slice","concat","__importDefault","exports","getSchemaVersionString","json_schema_merge_allof_1","require","jsonpointer_1","remove_undefined_objects_1","RMOAS","helpers_1","UNSUPPORTED_SCHEMA_PROPS","FORMAT_OPTIONS","INT8_MIN","Math","pow","INT8_MAX","INT16_MIN","INT16_MAX","INT32_MIN","INT32_MAX","INT64_MIN","INT64_MAX","UINT8_MIN","UINT8_MAX","UINT16_MIN","UINT16_MAX","UINT32_MIN","UINT32_MAX","UINT64_MIN","UINT64_MAX","FLOAT_MIN","FLOAT_MAX","DOUBLE_MIN","Number","MAX_VALUE","DOUBLE_MAX","encodePointer","str","replace","schema","api","isOAS31","$schema","jsonSchemaDialect","isPolymorphicSchema","isRequestBodySchema","searchForValueByPropAndPointer","property","pointer","schemas","locSplit","split","filter","Boolean","reverse","pointers","point","push","foundValue","rev","ii","example","isArray","examples","shift","default","err","toJSONSchema","data","opts","schemaAdditionalProperties","isSchema","additionalProperties","_a","addEnumsToDescriptions","currentLocation","globalDefaults","hideReadOnlyProperties","hideWriteOnlyProperties","isPolymorphicAllOfChild","prevDefaultSchemas","prevExampleSchemas","refLogger","transformer","isRef","$ref","allOf","ignoreAdditionalProperties","resolvers","description","obj","enum","arr","forEach","format","x-readme-ref-name","schemaWithoutAllOf","polyType","item","idx","polyOptions","properties","items","isObject","required","discriminator","mapping","mapping_1","keys","type","nullable","includes","Set","isNullable_1","nonPrimitives_1","entries","array","boolean","object","_b","_c","_d","_e","_f","_g","typeKey","keywords","reducedSchema","allowEmptyValue","deprecated","readOnly","title","writeOnly","oneOf","isPrimitive","reshapedExamples_1","examples_1","name","hasSchemaType","foundExample","prop","newPropSchema","propShouldBeUpdated","formatUpper","toUpperCase","minimum","maximum","userJwtDefault","foundDefault","enums","map","join"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/oas/dist/lib/openapi-to-json-schema.js"],"sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaVersionString = void 0;\nvar json_schema_merge_allof_1 = __importDefault(require(\"json-schema-merge-allof\"));\nvar jsonpointer_1 = __importDefault(require(\"jsonpointer\"));\nvar remove_undefined_objects_1 = __importDefault(require(\"remove-undefined-objects\"));\nvar RMOAS = __importStar(require(\"../rmoas.types\"));\nvar helpers_1 = require(\"./helpers\");\n/**\n * This list has been pulled from `openapi-schema-to-json-schema` but been slightly modified to fit\n * within the constraints in which ReadMe uses the output from this library in schema form\n * rendering as while properties like `readOnly` aren't represented within JSON Schema, we support\n * it within that library's handling of OpenAPI-friendly JSON Schema.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/main/src/consts.ts}\n */\nvar UNSUPPORTED_SCHEMA_PROPS = [\n    'example',\n    'externalDocs',\n    'xml',\n];\n/**\n * List partially sourced from `openapi-schema-to-json-schema`.\n *\n * @see {@link https://github.com/openapi-contrib/openapi-schema-to-json-schema/blob/master/lib/converters/schema.js#L140-L154}\n */\nvar FORMAT_OPTIONS = {\n    INT8_MIN: 0 - Math.pow(2, 7),\n    INT8_MAX: Math.pow(2, 7) - 1,\n    INT16_MIN: 0 - Math.pow(2, 15),\n    INT16_MAX: Math.pow(2, 15) - 1,\n    INT32_MIN: 0 - Math.pow(2, 31),\n    INT32_MAX: Math.pow(2, 31) - 1,\n    INT64_MIN: 0 - Math.pow(2, 63),\n    INT64_MAX: Math.pow(2, 63) - 1,\n    UINT8_MIN: 0,\n    UINT8_MAX: Math.pow(2, 8) - 1,\n    UINT16_MIN: 0,\n    UINT16_MAX: Math.pow(2, 16) - 1,\n    UINT32_MIN: 0,\n    UINT32_MAX: Math.pow(2, 32) - 1,\n    UINT64_MIN: 0,\n    UINT64_MAX: Math.pow(2, 64) - 1,\n    FLOAT_MIN: 0 - Math.pow(2, 128),\n    FLOAT_MAX: Math.pow(2, 128) - 1,\n    DOUBLE_MIN: 0 - Number.MAX_VALUE,\n    DOUBLE_MAX: Number.MAX_VALUE,\n};\n/**\n * Encode a string to be used as a JSON pointer.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param str String to encode into string that can be used as a JSON pointer.\n */\nfunction encodePointer(str) {\n    return str.replace('~', '~0').replace('/', '~1');\n}\nfunction getSchemaVersionString(schema, api) {\n    // If we're not on version 3.1.0, we always fall back to the default schema version for pre-3.1.0.\n    if (!RMOAS.isOAS31(api)) {\n        // This should remain as an HTTP url, not HTTPS.\n        return 'http://json-schema.org/draft-04/schema#';\n    }\n    /**\n     * If the schema indicates the version, prefer that.\n     *\n     * We use `as` here because the schema *should* be an OAS 3.1 schema due to the `isOAS31` check\n     * above.\n     */\n    if (schema.$schema) {\n        return schema.$schema;\n    }\n    // If the user defined a global schema version on their OAS document, prefer that.\n    if (api.jsonSchemaDialect) {\n        return api.jsonSchemaDialect;\n    }\n    return 'https://json-schema.org/draft/2020-12/schema#';\n}\nexports.getSchemaVersionString = getSchemaVersionString;\nfunction isPolymorphicSchema(schema) {\n    return 'allOf' in schema || 'anyOf' in schema || 'oneOf' in schema;\n}\nfunction isRequestBodySchema(schema) {\n    return 'content' in schema;\n}\n/**\n * Given a JSON pointer, a type of property to look for, and an array of schemas do a reverse\n * search through them until we find the JSON pointer, or part of it, within the array.\n *\n * This function will allow you to take a pointer like `/tags/name` and return back `buster` from\n * the following array:\n *\n * ```\n *  [\n *    {\n *      example: {id: 20}\n *    },\n *    {\n *      examples: {\n *        distinctName: {\n *          tags: {name: 'buster'}\n *        }\n *      }\n *    }\n *  ]\n * ```\n *\n * As with most things however, this is not without its quirks! If a deeply nested property shares\n * the same name as an example that's further up the stack (like `tags.id` and an example for `id`),\n * there's a chance that it'll be misidentified as having an example and receive the wrong value.\n *\n * That said, any example is usually better than no example though, so while it's quirky behavior\n * it shouldn't raise immediate cause for alarm.\n *\n * @see {@link https://tools.ietf.org/html/rfc6901}\n * @param property Specific type of schema property to look for a value for.\n * @param pointer JSON pointer to search for an example for.\n * @param schemas Array of previous schemas we've found relating to this pointer.\n */\nfunction searchForValueByPropAndPointer(property, pointer, schemas) {\n    if (schemas === void 0) { schemas = []; }\n    if (!schemas.length || !pointer.length) {\n        return undefined;\n    }\n    var locSplit = pointer.split('/').filter(Boolean).reverse();\n    var pointers = [];\n    var point = '';\n    for (var i = 0; i < locSplit.length; i += 1) {\n        point = \"/\".concat(locSplit[i]).concat(point);\n        pointers.push(point);\n    }\n    var foundValue;\n    var rev = __spreadArray([], schemas, true).reverse();\n    for (var i = 0; i < pointers.length; i += 1) {\n        for (var ii = 0; ii < rev.length; ii += 1) {\n            var schema = rev[ii];\n            if (property === 'example') {\n                if ('example' in schema) {\n                    schema = schema.example;\n                }\n                else {\n                    if (!Array.isArray(schema.examples) || !schema.examples.length) {\n                        continue;\n                    }\n                    // Prevent us from crashing if `examples` is a completely empty object.\n                    schema = __spreadArray([], schema.examples, true).shift();\n                }\n            }\n            else {\n                schema = schema.default;\n            }\n            try {\n                foundValue = jsonpointer_1.default.get(schema, pointers[i]);\n            }\n            catch (err) {\n                // If the schema we're looking at is `{obj: null}` and our pointer is `/obj/propertyName`\n                // `jsonpointer` will throw an error. If that happens, we should silently catch and toss it\n                // and return no example.\n            }\n            if (foundValue !== undefined) {\n                break;\n            }\n        }\n        if (foundValue !== undefined) {\n            break;\n        }\n    }\n    return foundValue;\n}\n/**\n * Given an OpenAPI-flavored JSON Schema, make an effort to modify it so it's shaped more towards\n * stock JSON Schema.\n *\n * Why do this?\n *\n *  1. OpenAPI 3.0.x supports its own flavor of JSON Schema that isn't fully compatible with most\n *    JSON Schema tooling (like `@readme/oas-form` or `@rjsf/core`).\n *  2. While validating an OpenAPI definition will prevent corrupted or improper schemas from\n *    occuring, we have a lot of legacy schemas in ReadMe that were ingested before we had proper\n *    validation in place, and as a result have some API definitions that will not pass validation\n *    right now. In addition to reshaping OAS-JSON Schema into JSON Schema this library will also\n *    fix these improper schemas: things like `type: object` having `items` instead of `properties`,\n *    or `type: array` missing `items`.\n *  3. To ease the burden of polymorphic handling on our form rendering engine we make an attempt\n *    to merge `allOf` schemas here.\n *  4. Additionally due to OpenAPI 3.0.x not supporting JSON Schema, in order to support the\n *    `example` keyword that OAS supports, we need to do some work in here to remap it into\n *    `examples`. However, since all we care about in respect to examples for usage within\n *    `@readme/oas-form`, we're only retaining primitives. This *slightly* deviates from JSON\n *    Schema in that JSON Schema allows for any schema to be an example, but since\n *    `@readme/oas-form` can only actually **render** primitives, that's what we're retaining.\n *  5. Though OpenAPI 3.1 does support full JSON Schema, this library should be able to handle it\n *    without any problems.\n *\n * And why use this over `@openapi-contrib/openapi-schema-to-json-schema`? Fortunately and\n * unfortunately we've got a lot of API definitions in our database that aren't currently valid so\n * we need to have a lot of bespoke handling for odd quirks, typos, and missing declarations that\n * might be present.\n *\n * @todo add support for `schema: false` and `not` cases.\n * @see {@link https://json-schema.org/draft/2019-09/json-schema-validation.html}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schemaObject}\n * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#schemaObject}\n * @param data OpenAPI Schema Object to convert to pure JSON Schema.\n */\nfunction toJSONSchema(data, opts) {\n    if (opts === void 0) { opts = {}; }\n    var schema = data === true ? {} : __assign({}, data);\n    var schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;\n    var _a = __assign({ addEnumsToDescriptions: false, currentLocation: '', globalDefaults: {}, hideReadOnlyProperties: false, hideWriteOnlyProperties: false, isPolymorphicAllOfChild: false, prevDefaultSchemas: [], prevExampleSchemas: [], refLogger: function () { return true; }, transformer: function (s) { return s; } }, opts), addEnumsToDescriptions = _a.addEnumsToDescriptions, currentLocation = _a.currentLocation, globalDefaults = _a.globalDefaults, hideReadOnlyProperties = _a.hideReadOnlyProperties, hideWriteOnlyProperties = _a.hideWriteOnlyProperties, isPolymorphicAllOfChild = _a.isPolymorphicAllOfChild, prevDefaultSchemas = _a.prevDefaultSchemas, prevExampleSchemas = _a.prevExampleSchemas, refLogger = _a.refLogger, transformer = _a.transformer;\n    // If this schema contains a `$ref`, it's circular and we shouldn't try to resolve it. Just\n    // return and move along.\n    if (RMOAS.isRef(schema)) {\n        refLogger(schema.$ref, 'ref');\n        return transformer({\n            $ref: schema.$ref,\n        });\n    }\n    // If we don't have a set type, but are dealing with an `anyOf`, `oneOf`, or `allOf`\n    // representation let's run through them and make sure they're good.\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n        // If this is an `allOf` schema we should make an attempt to merge so as to ease the burden on\n        // the tooling that ingests these schemas.\n        if ('allOf' in schema && Array.isArray(schema.allOf)) {\n            try {\n                schema = (0, json_schema_merge_allof_1.default)(schema, {\n                    ignoreAdditionalProperties: true,\n                    resolvers: {\n                        // `merge-json-schema-allof` by default takes the first `description` when you're\n                        // merging an `allOf` but because generally when you're merging two schemas together\n                        // with an `allOf` you want data in the subsequent schemas to be applied to the first\n                        // and `description` should be a part of that.\n                        description: function (obj) {\n                            return obj.slice(-1)[0];\n                        },\n                        // `merge-json-schema-allof` doesn't support merging enum arrays but since that's a\n                        // safe and simple operation as enums always contain primitives we can handle it\n                        // ourselves with a custom resolver.\n                        enum: function (obj) {\n                            var arr = [];\n                            obj.forEach(function (e) {\n                                arr = arr.concat(e);\n                            });\n                            return arr;\n                        },\n                        // JSON Schema ony supports examples with the `examples` property, since we're\n                        // ingesting OpenAPI definitions we need to add a custom resolver for its `example`\n                        // property.\n                        example: function (obj) { return obj[0]; },\n                        // JSON Schema has no support for `format` on anything other than `string`, but since\n                        // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we\n                        // can still merge schemas that may have those.\n                        format: function (obj) { return obj[0]; },\n                        // Since JSON Schema obviously doesn't know about our vendor extension we need to tell\n                        // the library to essentially ignore and pass it along.\n                        'x-readme-ref-name': function (obj) { return obj[0]; },\n                    },\n                });\n            }\n            catch (e) {\n                // If we can't merge the `allOf` for whatever reason (like if one item is a `string` and\n                // the other is a `object`) then we should completely remove it from the schema and continue\n                // with whatever we've got. Why? If we don't, any tooling that's ingesting this will need\n                // to account for the incompatible `allOf` and it may be subject to more breakages than\n                // just not having it present would be.\n                var schemaWithoutAllOf = __rest(schema, []);\n                schema = schemaWithoutAllOf;\n                delete schema.allOf;\n            }\n            // If after merging the `allOf` this schema still contains a `$ref` then it's circular and\n            // we shouldn't do anything else.\n            if (RMOAS.isRef(schema)) {\n                refLogger(schema.$ref, 'ref');\n                return transformer({\n                    $ref: schema.$ref,\n                });\n            }\n        }\n        ['anyOf', 'oneOf'].forEach(function (polyType) {\n            if (polyType in schema && Array.isArray(schema[polyType])) {\n                schema[polyType].forEach(function (item, idx) {\n                    var polyOptions = {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: \"\".concat(currentLocation, \"/\").concat(idx),\n                        globalDefaults: globalDefaults,\n                        hideReadOnlyProperties: hideReadOnlyProperties,\n                        hideWriteOnlyProperties: hideWriteOnlyProperties,\n                        isPolymorphicAllOfChild: false,\n                        prevDefaultSchemas: prevDefaultSchemas,\n                        prevExampleSchemas: prevExampleSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer,\n                    };\n                    // When `properties` or `items` are present alongside a polymorphic schema instead of\n                    // letting whatever JSON Schema interpreter is handling these constructed schemas we can\n                    // guide its hand a bit by manually transforming it into an inferred `allOf` of the\n                    // `properties` + the polymorph schema.\n                    //\n                    // This `allOf` schema will be merged together when fed through `toJSONSchema`.\n                    if ('properties' in schema) {\n                        schema[polyType][idx] = toJSONSchema({ allOf: [item, { properties: schema.properties }] }, polyOptions);\n                    }\n                    else if ('items' in schema) {\n                        schema[polyType][idx] = toJSONSchema({ allOf: [item, { items: schema.items }] }, polyOptions);\n                    }\n                    else {\n                        schema[polyType][idx] = toJSONSchema(item, polyOptions);\n                    }\n                    // Ensure that we don't have any invalid `required` booleans lying around.\n                    if ((0, helpers_1.isObject)(schema[polyType][idx]) &&\n                        'required' in schema[polyType][idx] &&\n                        typeof schema[polyType][idx].required === 'boolean') {\n                        delete schema[polyType][idx].required;\n                    }\n                });\n            }\n        });\n        if ('discriminator' in schema) {\n            if ('mapping' in schema.discriminator && typeof schema.discriminator.mapping === 'object') {\n                // Discriminator mappings aren't written as traditional `$ref` pointers so in order to log\n                // them to the supplied `refLogger`.\n                var mapping_1 = schema.discriminator.mapping;\n                Object.keys(mapping_1).forEach(function (k) {\n                    refLogger(mapping_1[k], 'discriminator');\n                });\n            }\n        }\n    }\n    // If this schema is malformed for some reason, let's do our best to repair it.\n    if (!('type' in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {\n        if ('properties' in schema) {\n            schema.type = 'object';\n        }\n        else if ('items' in schema) {\n            schema.type = 'array';\n        }\n        else {\n            // If there's still no `type` on the schema we should leave it alone because we don't have a\n            // great way to know if it's part of a nested schema that should, and couldn't be merged,\n            // into another, or it's just purely malformed.\n            //\n            // Whatever tooling that ingests the generated schema should handle it however it needs to.\n        }\n    }\n    if ('type' in schema) {\n        // `nullable` isn't a thing in JSON Schema but it was in OpenAPI 3.0 so we should retain and\n        // translate it into something that's compatible with JSON Schema.\n        if ('nullable' in schema) {\n            if (Array.isArray(schema.type)) {\n                schema.type.push('null');\n            }\n            else if (schema.type !== null && schema.type !== 'null') {\n                schema.type = [schema.type, 'null'];\n            }\n            delete schema.nullable;\n        }\n        if (schema.type === null) {\n            // `type: null` is possible in JSON Schema but we're translating it to a string version\n            // so we don't need to worry about asserting nullish types in our implementations of this\n            // generated schema.\n            schema.type = 'null';\n        }\n        else if (Array.isArray(schema.type)) {\n            if (schema.type.includes(null)) {\n                schema.type[schema.type.indexOf(null)] = 'null';\n            }\n            schema.type = Array.from(new Set(schema.type));\n            // We don't need `type: [<type>]` when we can just as easily make it `type: <type>`.\n            if (schema.type.length === 1) {\n                schema.type = schema.type.shift();\n            }\n            else if (schema.type.includes('array') || schema.type.includes('boolean') || schema.type.includes('object')) {\n                // If we have a `null` type but there's only two types present then we can remove `null`\n                // as an option and flag the whole schema as `nullable`.\n                var isNullable_1 = schema.type.includes('null');\n                if (schema.type.length === 2 && isNullable_1) {\n                    // If this is `array | null` or `object | null` then we don't need to do anything.\n                }\n                else {\n                    // If this mixed type has non-primitives then we for convenience of our implementation\n                    // we're moving them into a `oneOf`.\n                    var nonPrimitives_1 = [];\n                    // Because arrays, booleans, and objects are not compatible with any other schem type\n                    // other than null we're moving them into an isolated `oneOf`, and as such want to take\n                    // with it its specific properties that may be present on our current schema.\n                    Object.entries({\n                        // https://json-schema.org/understanding-json-schema/reference/array.html\n                        array: [\n                            'additionalItems',\n                            'contains',\n                            'items',\n                            'maxContains',\n                            'maxItems',\n                            'minContains',\n                            'minItems',\n                            'prefixItems',\n                            'uniqueItems',\n                        ],\n                        // https://json-schema.org/understanding-json-schema/reference/boolean.html\n                        boolean: [\n                        // Booleans don't have any boolean-specific properties.\n                        ],\n                        // https://json-schema.org/understanding-json-schema/reference/object.html\n                        object: [\n                            'additionalProperties',\n                            'maxProperties',\n                            'minProperties',\n                            'nullable',\n                            'patternProperties',\n                            'properties',\n                            'propertyNames',\n                            'required',\n                        ],\n                    }).forEach(function (_a) {\n                        var _b, _c, _d, _e, _f, _g;\n                        var typeKey = _a[0], keywords = _a[1];\n                        if (!schema.type.includes(typeKey)) {\n                            return;\n                        }\n                        var reducedSchema = (0, remove_undefined_objects_1.default)({\n                            type: isNullable_1 ? [typeKey, 'null'] : typeKey,\n                            allowEmptyValue: (_b = schema.allowEmptyValue) !== null && _b !== void 0 ? _b : undefined,\n                            deprecated: (_c = schema.deprecated) !== null && _c !== void 0 ? _c : undefined,\n                            description: (_d = schema.description) !== null && _d !== void 0 ? _d : undefined,\n                            readOnly: (_e = schema.readOnly) !== null && _e !== void 0 ? _e : undefined,\n                            title: (_f = schema.title) !== null && _f !== void 0 ? _f : undefined,\n                            writeOnly: (_g = schema.writeOnly) !== null && _g !== void 0 ? _g : undefined,\n                        });\n                        keywords.forEach(function (t) {\n                            if (t in schema) {\n                                reducedSchema[t] = schema[t];\n                                delete schema[t];\n                            }\n                        });\n                        nonPrimitives_1.push(reducedSchema);\n                    });\n                    schema.type = schema.type.filter(function (t) { return t !== 'array' && t !== 'boolean' && t !== 'object'; });\n                    if (schema.type.length === 1) {\n                        schema.type = schema.type.shift();\n                    }\n                    // Because we may have encountered a fully mixed non-primitive type like `array | object`\n                    // we only want to retain the existing schema object if we still have types remaining\n                    // in it.\n                    if (schema.type.length > 1) {\n                        schema = { oneOf: __spreadArray([schema], nonPrimitives_1, true) };\n                    }\n                    else {\n                        schema = { oneOf: nonPrimitives_1 };\n                    }\n                }\n            }\n        }\n    }\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {\n        if ('default' in schema && (0, helpers_1.isObject)(schema.default)) {\n            prevDefaultSchemas.push({ default: schema.default });\n        }\n        // JSON Schema doesn't support OpenAPI-style examples so we need to reshape them a bit.\n        if ('example' in schema) {\n            // Only bother adding primitive examples.\n            if ((0, helpers_1.isPrimitive)(schema.example)) {\n                schema.examples = [schema.example];\n            }\n            else if (Array.isArray(schema.example)) {\n                schema.examples = schema.example.filter(function (example) { return (0, helpers_1.isPrimitive)(example); });\n                if (!schema.examples.length) {\n                    delete schema.examples;\n                }\n            }\n            else {\n                prevExampleSchemas.push({ example: schema.example });\n            }\n            delete schema.example;\n        }\n        else if ('examples' in schema) {\n            var reshapedExamples_1 = false;\n            if (typeof schema.examples === 'object' && !Array.isArray(schema.examples)) {\n                var examples_1 = [];\n                Object.keys(schema.examples).forEach(function (name) {\n                    var example = schema.examples[name];\n                    if ('$ref' in example) {\n                        // no-op because any `$ref` example here after dereferencing is circular so we should\n                        // ignore it\n                        refLogger(example.$ref, 'ref');\n                    }\n                    else if ('value' in example) {\n                        if ((0, helpers_1.isPrimitive)(example.value)) {\n                            examples_1.push(example.value);\n                            reshapedExamples_1 = true;\n                        }\n                        else if (Array.isArray(example.value) && (0, helpers_1.isPrimitive)(example.value[0])) {\n                            examples_1.push(example.value[0]);\n                            reshapedExamples_1 = true;\n                        }\n                        else {\n                            // If this example is neither a primitive or an array we should dump it into the\n                            // `prevExampleSchemas` array because we might be able to extract an example from it\n                            // further downstream.\n                            prevExampleSchemas.push({\n                                example: example.value,\n                            });\n                        }\n                    }\n                });\n                if (examples_1.length) {\n                    reshapedExamples_1 = true;\n                    schema.examples = examples_1;\n                }\n            }\n            else if (Array.isArray(schema.examples) && (0, helpers_1.isPrimitive)(schema.examples[0])) {\n                // We haven't reshaped `examples` here, but since it's in a state that's preferrable to us\n                // let's keep it around.\n                reshapedExamples_1 = true;\n            }\n            if (!reshapedExamples_1) {\n                delete schema.examples;\n            }\n        }\n        // If we didn't have any immediately defined examples, let's search backwards and see if we can\n        // find one. But as we're only looking for primitive example, only try to search for one if\n        // we're dealing with a primitive schema.\n        if (!(0, helpers_1.hasSchemaType)(schema, 'array') && !(0, helpers_1.hasSchemaType)(schema, 'object') && !schema.examples) {\n            var foundExample = searchForValueByPropAndPointer('example', currentLocation, prevExampleSchemas);\n            if (foundExample) {\n                // We can only really deal with primitives, so only promote those as the found example if\n                // it is.\n                if ((0, helpers_1.isPrimitive)(foundExample) || (Array.isArray(foundExample) && (0, helpers_1.isPrimitive)(foundExample[0]))) {\n                    schema.examples = [foundExample];\n                }\n            }\n        }\n        if ((0, helpers_1.hasSchemaType)(schema, 'array')) {\n            if ('items' in schema) {\n                if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {\n                    // `items` contains a `$ref`, so since it's circular we should do a no-op here and log\n                    // and ignore it.\n                    refLogger(schema.items.$ref, 'ref');\n                }\n                else if (schema.items !== true) {\n                    // Run through the arrays contents and clean them up.\n                    schema.items = toJSONSchema(schema.items, {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: \"\".concat(currentLocation, \"/0\"),\n                        globalDefaults: globalDefaults,\n                        hideReadOnlyProperties: hideReadOnlyProperties,\n                        hideWriteOnlyProperties: hideWriteOnlyProperties,\n                        prevExampleSchemas: prevExampleSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer,\n                    });\n                    // If we have a non-array `required` entry in our `items` schema then it's invalid and we\n                    // should remove it. We only support non-array boolean `required` properties inside object\n                    // properties.\n                    if ((0, helpers_1.isObject)(schema.items) && 'required' in schema.items && !Array.isArray(schema.items.required)) {\n                        delete schema.items.required;\n                    }\n                }\n            }\n            else if ('properties' in schema || 'additionalProperties' in schema) {\n                // This is a fix to handle cases where someone may have typod `items` as `properties` on an\n                // array. Since throwing a complete failure isn't ideal, we can see that they meant for the\n                // type to be `object`, so we can do our best to shape the data into what they were\n                // intending it to be.\n                schema.type = 'object';\n            }\n            else {\n                // This is a fix to handle cases where we have a malformed array with no `items` property\n                // present.\n                schema.items = {};\n            }\n        }\n        else if ((0, helpers_1.hasSchemaType)(schema, 'object')) {\n            if ('properties' in schema) {\n                Object.keys(schema.properties).forEach(function (prop) {\n                    if (Array.isArray(schema.properties[prop]) ||\n                        (typeof schema.properties[prop] === 'object' && schema.properties[prop] !== null)) {\n                        var newPropSchema = toJSONSchema(schema.properties[prop], {\n                            addEnumsToDescriptions: addEnumsToDescriptions,\n                            currentLocation: \"\".concat(currentLocation, \"/\").concat(encodePointer(prop)),\n                            globalDefaults: globalDefaults,\n                            hideReadOnlyProperties: hideReadOnlyProperties,\n                            hideWriteOnlyProperties: hideWriteOnlyProperties,\n                            prevDefaultSchemas: prevDefaultSchemas,\n                            prevExampleSchemas: prevExampleSchemas,\n                            refLogger: refLogger,\n                            transformer: transformer,\n                        });\n                        // If this property is read or write only then we should fully hide it from its parent schema.\n                        var propShouldBeUpdated = true;\n                        if ((hideReadOnlyProperties || hideWriteOnlyProperties) && !Object.keys(newPropSchema).length) {\n                            // We should only delete this schema if it wasn't already empty though. We do this\n                            // because we (un)fortunately have handling in our API Explorer form system for\n                            // schemas that are devoid of any `type` declaration.\n                            if (Object.keys(schema.properties[prop]).length > 0) {\n                                delete schema.properties[prop];\n                                propShouldBeUpdated = false;\n                            }\n                        }\n                        if (propShouldBeUpdated) {\n                            schema.properties[prop] = newPropSchema;\n                            /**\n                             * JSON Schema does not have any support for `required: <boolean>` but because some\n                             * of our users do this, and it does not throw OpenAPI validation errors thanks to\n                             * some extremely loose typings around `schema` in the official JSON Schema\n                             * definitions that the OAI offers, we're opting to support these users and upgrade\n                             * their invalid `required` definitions into ones that our tooling can interpret.\n                             *\n                             * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/schemas/v3.1/schema.json#L1114-L1121}\n                             */\n                            if ((0, helpers_1.isObject)(newPropSchema) &&\n                                'required' in newPropSchema &&\n                                typeof newPropSchema.required === 'boolean' &&\n                                newPropSchema.required === true) {\n                                if ('required' in schema && Array.isArray(schema.required)) {\n                                    schema.required.push(prop);\n                                }\n                                else {\n                                    schema.required = [prop];\n                                }\n                                delete schema.properties[prop].required;\n                            }\n                        }\n                    }\n                });\n                // If we want to hide all readOnly or writeOnly properites and it happens to be that this\n                // object was comprised of only those then we shouldn't render this object.\n                if (hideReadOnlyProperties || hideWriteOnlyProperties) {\n                    if (!Object.keys(schema.properties).length) {\n                        return transformer({});\n                    }\n                }\n            }\n            if (typeof schemaAdditionalProperties === 'object' && schemaAdditionalProperties !== null) {\n                // If this `additionalProperties` is completely empty and devoid of any sort of schema,\n                // treat it as such. Otherwise let's recurse into it and see if we can sort it out.\n                if (!('type' in schemaAdditionalProperties) &&\n                    !('$ref' in schemaAdditionalProperties) &&\n                    // We know it will be a schema object because it's dereferenced\n                    !isPolymorphicSchema(schemaAdditionalProperties)) {\n                    schema.additionalProperties = true;\n                }\n                else {\n                    // We know it will be a schema object because it's dereferenced\n                    schema.additionalProperties = toJSONSchema(schemaAdditionalProperties, {\n                        addEnumsToDescriptions: addEnumsToDescriptions,\n                        currentLocation: currentLocation,\n                        globalDefaults: globalDefaults,\n                        hideReadOnlyProperties: hideReadOnlyProperties,\n                        hideWriteOnlyProperties: hideWriteOnlyProperties,\n                        prevDefaultSchemas: prevDefaultSchemas,\n                        prevExampleSchemas: prevExampleSchemas,\n                        refLogger: refLogger,\n                        transformer: transformer,\n                    });\n                }\n            }\n            // Since neither `properties` and `additionalProperties` are actually required to be present\n            // on an object, since we construct this schema work to build up a form we still need\n            // *something* for the user to enter in for this object so we'll add back in\n            // `additionalProperties` for that.\n            if (!isPolymorphicSchema(schema) && !('properties' in schema) && !('additionalProperties' in schema)) {\n                schema.additionalProperties = true;\n            }\n        }\n    }\n    // Ensure that number schemas formats have properly constrained min/max attributes according to\n    // whatever type of `format` and `type` they adhere to.\n    if ('format' in schema) {\n        var formatUpper = schema.format.toUpperCase();\n        if (\"\".concat(formatUpper, \"_MIN\") in FORMAT_OPTIONS) {\n            if ((!schema.minimum && schema.minimum !== 0) || schema.minimum < FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")]) {\n                schema.minimum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MIN\")];\n            }\n        }\n        if (\"\".concat(formatUpper, \"_MAX\") in FORMAT_OPTIONS) {\n            if ((!schema.maximum && schema.maximum !== 0) || schema.maximum > FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")]) {\n                schema.maximum = FORMAT_OPTIONS[\"\".concat(formatUpper, \"_MAX\")];\n            }\n        }\n    }\n    /**\n     * Users can pass in parameter defaults via JWT User Data. We're checking to see if the defaults\n     * being passed in exist on endpoints via jsonpointer\n     *\n     * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}\n     */\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) &&\n        globalDefaults &&\n        Object.keys(globalDefaults).length > 0 &&\n        currentLocation) {\n        try {\n            var userJwtDefault = jsonpointer_1.default.get(globalDefaults, currentLocation);\n            if (userJwtDefault) {\n                schema.default = userJwtDefault;\n            }\n        }\n        catch (err) {\n            // If jsonpointer returns an error, we won't show any defaults for that path.\n        }\n    }\n    // Only add a default value if we actually have one.\n    if ('default' in schema && typeof schema.default !== 'undefined') {\n        if ((0, helpers_1.hasSchemaType)(schema, 'object')) {\n            // Defaults for `object` and types have been dereferenced into their children schemas already\n            // above so we don't need to preserve this default anymore.\n            delete schema.default;\n        }\n        else {\n            // If it's an enum and not the response schema, add the default to the description.\n            // If there's an existing description, trim trailing new lines so it doesn't look ugly.\n            if ('enum' in schema && !addEnumsToDescriptions) {\n                schema.description = schema.description\n                    ? \"\".concat(schema.description.replace(/\\n$/, ''), \"\\n\\nDefault: `\").concat(schema.default, \"`\")\n                    : \"Default: \".concat(schema.default);\n            }\n            if (('allowEmptyValue' in schema && schema.allowEmptyValue && schema.default === '') || schema.default !== '') {\n                // If we have `allowEmptyValue` present, and the default is actually an empty string, let it\n                // through as it's allowed.\n            }\n            else {\n                // If the default is empty and we don't want to allowEmptyValue, we need to remove the\n                // default.\n                delete schema.default;\n            }\n        }\n    }\n    else if (prevDefaultSchemas.length) {\n        var foundDefault = searchForValueByPropAndPointer('default', currentLocation, prevDefaultSchemas);\n        // We shouldn't ever set an object default out of the parent lineage tree defaults because\n        // the contents of that object will be set on the schema that they're a part of. Setting\n        // that object as well would result us in duplicating the defaults for that schema in two\n        // places.\n        if ((0, helpers_1.isPrimitive)(foundDefault) ||\n            foundDefault === null ||\n            (Array.isArray(foundDefault) && (0, helpers_1.hasSchemaType)(schema, 'array'))) {\n            schema.default = foundDefault;\n        }\n    }\n    if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && 'enum' in schema && Array.isArray(schema.enum)) {\n        // Enums should not have duplicated items as those will break AJV validation.\n        // If we ever target ES6 for typescript we can drop this array.from.\n        // https://stackoverflow.com/questions/33464504/using-spread-syntax-and-new-set-with-typescript/56870548\n        schema.enum = Array.from(new Set(schema.enum));\n        // If we want to add enums to descriptions (like in the case of response JSON Schema)\n        // generation we need to convert them into a list of Markdown tilda'd strings. We're also\n        // filtering away empty and falsy strings here because adding empty `` blocks to the description\n        // will serve nobody any good.\n        if (addEnumsToDescriptions) {\n            var enums = schema.enum\n                .filter(Boolean)\n                .map(function (str) { return \"`\".concat(str, \"`\"); })\n                .join(' ');\n            if (enums.length) {\n                if ('description' in schema) {\n                    schema.description += \"\\n\\n\".concat(enums);\n                }\n                else {\n                    schema.description = enums;\n                }\n            }\n        }\n    }\n    // Clean up any remaining `items` or `properties` schema fragments lying around if there's also\n    // polymorphism present.\n    if ('anyOf' in schema || 'oneOf' in schema) {\n        if ('properties' in schema) {\n            delete schema.properties;\n        }\n        if ('items' in schema) {\n            delete schema.items;\n        }\n    }\n    // Remove unsupported JSON Schema props.\n    for (var i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {\n        // Using the as here because the purpose is to delete keys we don't expect, so of course the\n        // typing won't work\n        delete schema[UNSUPPORTED_SCHEMA_PROPS[i]];\n    }\n    // If we want to hide any `readOnly` or `writeOnly` schemas, and this one is that, then we\n    // shouldn't return anything.\n    if (hideReadOnlyProperties && 'readOnly' in schema && schema.readOnly === true) {\n        return {};\n    }\n    else if (hideWriteOnlyProperties && 'writeOnly' in schema && schema.writeOnly === true) {\n        return {};\n    }\n    return transformer(schema);\n}\nexports.default = toJSONSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}