{"ast":null,"code":"const swaggerMethods = require('@apidevtools/swagger-methods');\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst util = require('../../util');\nmodule.exports = validateSpec;\n\n/**\n * Validates parts of the OpenAPI 3.0 and 3.1 that aren't covered by their JSON Schema definitions.\n *\n * @todo This library currently does not validate required properties like the Swagger validator does due to some\n *  gnarly quirks with cases where a required property exists within a `oneOf` or `anyOf` (and within a child `allOf`\n *  of one of those). See https://api.apis.guru/v2/specs/twitter.com/labs/2.13/openapi.yaml for a good example.\n *\n * @param {SwaggerObject} api\n * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md\n * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md\n */\nfunction validateSpec(api) {\n  const operationIds = [];\n  Object.keys(api.paths || {}).forEach(pathName => {\n    const path = api.paths[pathName];\n    const pathId = `/paths${pathName}`;\n    if (path && pathName.indexOf('/') === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  });\n\n  // There's a problem with how the 3.0 schema uses `patternProperties` for defining the format of scheme names that it\n  // ignores anything that doesn't match, so if you for example have a space in a schema name it'll be seen as valid\n  // when it should instead trigger a validation error.\n  //\n  // https://github.com/APIDevTools/swagger-parser/issues/184\n  if (api.openapi.startsWith('3.0')) {\n    if (api.components) {\n      Object.keys(api.components).forEach(componentType => {\n        Object.keys(api.components[componentType]).forEach(componentName => {\n          const componentId = `/components/${componentType}/${componentName}`;\n          if (!/^[a-zA-Z0-9.\\-_]+$/.test(componentName)) {\n            throw ono.syntax(`Validation failed. ${componentId} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`);\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire OpenAPI API definition\n * @param {object}        path          - A Path object, from the OpenAPI API definition\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\nfunction validatePath(api, path, pathId, operationIds) {\n  // `@apidevtools/swagger-methods` doesn't ship a `trace` method so we need to improvise.\n  [...swaggerMethods, 'trace'].forEach(operationName => {\n    const operation = path[operationName];\n    const operationId = `${pathId}/${operationName}`;\n    if (operation) {\n      const declaredOperationId = operation.operationId;\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        } else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n      validateParameters(api, path, pathId, operation, operationId);\n      Object.keys(operation.responses || {}).forEach(responseCode => {\n        const response = operation.responses[responseCode];\n        const responseId = `${operationId}/responses/${responseCode}`;\n        validateResponse(responseCode, response || {}, responseId);\n      });\n    }\n  });\n}\n\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\nfunction validateParameters(api, path, pathId, operation, operationId) {\n  const pathParams = path.parameters || [];\n  const operationParams = operation.parameters || [];\n\n  // Check for duplicate path parameters.\n  try {\n    checkForDuplicates(pathParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  }\n\n  // Check for duplicate operation parameters.\n  try {\n    checkForDuplicates(operationParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  }\n\n  // Combine the path and operation parameters, with the operation params taking precedence over the path params.\n  const params = pathParams.reduce((combinedParams, value) => {\n    const duplicate = combinedParams.some(param => {\n      return param.in === value.in && param.name === value.name;\n    });\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n    return combinedParams;\n  }, operationParams.slice());\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\nfunction validatePathParameters(params, pathId, operationId) {\n  // Find all `{placeholders}` in the path string. And because paths can have path parameters duped we need to convert\n  // this to a unique array so we can eliminate false positives of placeholders that might be duplicated.\n  const placeholders = [...new Set(pathId.match(util.swaggerParamRegExp) || [])];\n  params.filter(param => param.in === 'path').forEach(param => {\n    if (param.required !== true) {\n      throw ono.syntax('Validation failed. Path parameters cannot be optional. ' + `Set required=true for the \"${param.name}\" parameter at ${operationId}`);\n    }\n    const match = placeholders.indexOf(`{${param.name}}`);\n    if (match === -1) {\n      throw ono.syntax(`Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` + `but there is no corresponding {${param.name}} in the path string`);\n    }\n    placeholders.splice(match, 1);\n  });\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateParameterTypes(params, api, operation, operationId) {\n  params.forEach(param => {\n    /**\n     * @todo add better handling when `content` is present instead of `schema`.\n     * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#fixed-fields-10\n     * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-10\n     */\n    if (!param.schema && param.content) {\n      return;\n    }\n    const parameterId = `${operationId}/parameters/${param.name}`;\n    validateSchema(param.schema, parameterId);\n  });\n}\n\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\nfunction checkForDuplicates(params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    const outer = params[i];\n    for (let j = i + 1; j < params.length; j++) {\n      const inner = params[j];\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\nfunction validateResponse(code, response, responseId) {\n  Object.keys(response.headers || {}).forEach(headerName => {\n    const header = response.headers[headerName];\n    const headerId = `${responseId}/headers/${headerName}`;\n    if (header.schema) {\n      validateSchema(header.schema, headerId);\n    } else if (header.content) {\n      Object.keys(header.content).forEach(mediaType => {\n        if (header.content[mediaType].schema) {\n          validateSchema(header.content[mediaType].schema || {}, `${headerId}/content/${mediaType}/schema`);\n        }\n      });\n    }\n  });\n  if (response.content) {\n    Object.keys(response.content).forEach(mediaType => {\n      if (response.content[mediaType].schema) {\n        validateSchema(response.content[mediaType].schema || {}, `${responseId}/content/${mediaType}/schema`);\n      }\n    });\n  }\n}\n\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\nfunction validateSchema(schema, schemaId) {\n  if (schema.type === 'array' && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}","map":{"version":3,"names":["swaggerMethods","require","ono","util","module","exports","validateSpec","api","operationIds","Object","keys","paths","forEach","pathName","path","pathId","indexOf","validatePath","openapi","startsWith","components","componentType","componentName","componentId","test","syntax","operationName","operation","operationId","declaredOperationId","push","validateParameters","responses","responseCode","response","responseId","validateResponse","pathParams","parameters","operationParams","checkForDuplicates","e","params","reduce","combinedParams","value","duplicate","some","param","in","name","slice","validatePathParameters","validateParameterTypes","placeholders","Set","match","swaggerParamRegExp","filter","required","splice","length","schema","content","parameterId","validateSchema","i","outer","j","inner","code","headers","headerName","header","headerId","mediaType","schemaId","type","items"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/@readme/openapi-parser/lib/validators/spec/openapi.js"],"sourcesContent":["const swaggerMethods = require('@apidevtools/swagger-methods');\nconst { ono } = require('@jsdevtools/ono');\n\nconst util = require('../../util');\n\nmodule.exports = validateSpec;\n\n/**\n * Validates parts of the OpenAPI 3.0 and 3.1 that aren't covered by their JSON Schema definitions.\n *\n * @todo This library currently does not validate required properties like the Swagger validator does due to some\n *  gnarly quirks with cases where a required property exists within a `oneOf` or `anyOf` (and within a child `allOf`\n *  of one of those). See https://api.apis.guru/v2/specs/twitter.com/labs/2.13/openapi.yaml for a good example.\n *\n * @param {SwaggerObject} api\n * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md\n * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md\n */\nfunction validateSpec(api) {\n  const operationIds = [];\n  Object.keys(api.paths || {}).forEach(pathName => {\n    const path = api.paths[pathName];\n    const pathId = `/paths${pathName}`;\n\n    if (path && pathName.indexOf('/') === 0) {\n      validatePath(api, path, pathId, operationIds);\n    }\n  });\n\n  // There's a problem with how the 3.0 schema uses `patternProperties` for defining the format of scheme names that it\n  // ignores anything that doesn't match, so if you for example have a space in a schema name it'll be seen as valid\n  // when it should instead trigger a validation error.\n  //\n  // https://github.com/APIDevTools/swagger-parser/issues/184\n  if (api.openapi.startsWith('3.0')) {\n    if (api.components) {\n      Object.keys(api.components).forEach(componentType => {\n        Object.keys(api.components[componentType]).forEach(componentName => {\n          const componentId = `/components/${componentType}/${componentName}`;\n\n          if (!/^[a-zA-Z0-9.\\-_]+$/.test(componentName)) {\n            throw ono.syntax(\n              `Validation failed. ${componentId} has an invalid name. Component names should match against: /^[a-zA-Z0-9.-_]+$/`\n            );\n          }\n        });\n      });\n    }\n  }\n}\n\n/**\n * Validates the given path.\n *\n * @param {SwaggerObject} api           - The entire OpenAPI API definition\n * @param {object}        path          - A Path object, from the OpenAPI API definition\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {string}        operationIds  - An array of collected operationIds found in other paths\n */\nfunction validatePath(api, path, pathId, operationIds) {\n  // `@apidevtools/swagger-methods` doesn't ship a `trace` method so we need to improvise.\n  [...swaggerMethods, 'trace'].forEach(operationName => {\n    const operation = path[operationName];\n    const operationId = `${pathId}/${operationName}`;\n\n    if (operation) {\n      const declaredOperationId = operation.operationId;\n      if (declaredOperationId) {\n        if (operationIds.indexOf(declaredOperationId) === -1) {\n          operationIds.push(declaredOperationId);\n        } else {\n          throw ono.syntax(`Validation failed. Duplicate operation id '${declaredOperationId}'`);\n        }\n      }\n\n      validateParameters(api, path, pathId, operation, operationId);\n\n      Object.keys(operation.responses || {}).forEach(responseCode => {\n        const response = operation.responses[responseCode];\n        const responseId = `${operationId}/responses/${responseCode}`;\n        validateResponse(responseCode, response || {}, responseId);\n      });\n    }\n  });\n}\n\n/**\n * Validates the parameters for the given operation.\n *\n * @param {SwaggerObject} api           - The entire Swagger API object\n * @param {object}        path          - A Path object, from the Swagger API\n * @param {string}        pathId        - A value that uniquely identifies the path\n * @param {object}        operation     - An Operation object, from the Swagger API\n * @param {string}        operationId   - A value that uniquely identifies the operation\n */\nfunction validateParameters(api, path, pathId, operation, operationId) {\n  const pathParams = path.parameters || [];\n  const operationParams = operation.parameters || [];\n\n  // Check for duplicate path parameters.\n  try {\n    checkForDuplicates(pathParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${pathId} has duplicate parameters`);\n  }\n\n  // Check for duplicate operation parameters.\n  try {\n    checkForDuplicates(operationParams);\n  } catch (e) {\n    throw ono.syntax(e, `Validation failed. ${operationId} has duplicate parameters`);\n  }\n\n  // Combine the path and operation parameters, with the operation params taking precedence over the path params.\n  const params = pathParams.reduce((combinedParams, value) => {\n    const duplicate = combinedParams.some(param => {\n      return param.in === value.in && param.name === value.name;\n    });\n\n    if (!duplicate) {\n      combinedParams.push(value);\n    }\n\n    return combinedParams;\n  }, operationParams.slice());\n\n  validatePathParameters(params, pathId, operationId);\n  validateParameterTypes(params, api, operation, operationId);\n}\n\n/**\n * Validates path parameters for the given path.\n *\n * @param   {object[]}  params        - An array of Parameter objects\n * @param   {string}    pathId        - A value that uniquely identifies the path\n * @param   {string}    operationId   - A value that uniquely identifies the operation\n */\nfunction validatePathParameters(params, pathId, operationId) {\n  // Find all `{placeholders}` in the path string. And because paths can have path parameters duped we need to convert\n  // this to a unique array so we can eliminate false positives of placeholders that might be duplicated.\n  const placeholders = [...new Set(pathId.match(util.swaggerParamRegExp) || [])];\n\n  params\n    .filter(param => param.in === 'path')\n    .forEach(param => {\n      if (param.required !== true) {\n        throw ono.syntax(\n          'Validation failed. Path parameters cannot be optional. ' +\n            `Set required=true for the \"${param.name}\" parameter at ${operationId}`\n        );\n      }\n\n      const match = placeholders.indexOf(`{${param.name}}`);\n      if (match === -1) {\n        throw ono.syntax(\n          `Validation failed. ${operationId} has a path parameter named \"${param.name}\", ` +\n            `but there is no corresponding {${param.name}} in the path string`\n        );\n      }\n\n      placeholders.splice(match, 1);\n    });\n\n  if (placeholders.length > 0) {\n    throw ono.syntax(`Validation failed. ${operationId} is missing path parameter(s) for ${placeholders}`);\n  }\n}\n\n/**\n * Validates data types of parameters for the given operation.\n *\n * @param   {object[]}  params       -  An array of Parameter objects\n * @param   {object}    api          -  The entire Swagger API object\n * @param   {object}    operation    -  An Operation object, from the Swagger API\n * @param   {string}    operationId  -  A value that uniquely identifies the operation\n */\nfunction validateParameterTypes(params, api, operation, operationId) {\n  params.forEach(param => {\n    /**\n     * @todo add better handling when `content` is present instead of `schema`.\n     * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#fixed-fields-10\n     * @link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-10\n     */\n    if (!param.schema && param.content) {\n      return;\n    }\n\n    const parameterId = `${operationId}/parameters/${param.name}`;\n\n    validateSchema(param.schema, parameterId);\n  });\n}\n\n/**\n * Checks the given parameter list for duplicates, and throws an error if found.\n *\n * @param   {object[]}  params  - An array of Parameter objects\n */\nfunction checkForDuplicates(params) {\n  for (let i = 0; i < params.length - 1; i++) {\n    const outer = params[i];\n    for (let j = i + 1; j < params.length; j++) {\n      const inner = params[j];\n      if (outer.name === inner.name && outer.in === inner.in) {\n        throw ono.syntax(`Validation failed. Found multiple ${outer.in} parameters named \"${outer.name}\"`);\n      }\n    }\n  }\n}\n\n/**\n * Validates the given response object.\n *\n * @param   {string}    code        -  The HTTP response code (or \"default\")\n * @param   {object}    response    -  A Response object, from the Swagger API\n * @param   {string}    responseId  -  A value that uniquely identifies the response\n */\nfunction validateResponse(code, response, responseId) {\n  Object.keys(response.headers || {}).forEach(headerName => {\n    const header = response.headers[headerName];\n    const headerId = `${responseId}/headers/${headerName}`;\n\n    if (header.schema) {\n      validateSchema(header.schema, headerId);\n    } else if (header.content) {\n      Object.keys(header.content).forEach(mediaType => {\n        if (header.content[mediaType].schema) {\n          validateSchema(header.content[mediaType].schema || {}, `${headerId}/content/${mediaType}/schema`);\n        }\n      });\n    }\n  });\n\n  if (response.content) {\n    Object.keys(response.content).forEach(mediaType => {\n      if (response.content[mediaType].schema) {\n        validateSchema(response.content[mediaType].schema || {}, `${responseId}/content/${mediaType}/schema`);\n      }\n    });\n  }\n}\n\n/**\n * Validates the given Swagger schema object.\n *\n * @param {object}    schema      - A Schema object, from the Swagger API\n * @param {string}    schemaId    - A value that uniquely identifies the schema object\n */\nfunction validateSchema(schema, schemaId) {\n  if (schema.type === 'array' && !schema.items) {\n    throw ono.syntax(`Validation failed. ${schemaId} is an array, so it must include an \"items\" schema`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}