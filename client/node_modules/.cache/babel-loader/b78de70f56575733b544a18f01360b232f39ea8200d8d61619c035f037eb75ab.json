{"ast":null,"code":"/* eslint-disable no-unused-vars */\nconst {\n  ono\n} = require('@jsdevtools/ono');\nconst $RefParser = require('@readme/json-schema-ref-parser');\nconst dereference = require('@readme/json-schema-ref-parser/lib/dereference');\nconst normalizeArgs = require('@readme/json-schema-ref-parser/lib/normalize-args');\nconst maybe = require('call-me-maybe');\nconst Options = require('./options');\nconst util = require('./util');\nconst validateSchema = require('./validators/schema');\nconst validateSpec = require('./validators/spec');\nmodule.exports = OpenAPIParser;\n\n/**\n * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,\n * and provides methods for traversing, dereferencing, and validating the API.\n *\n * @class\n * @augments $RefParser\n */\nfunction OpenAPIParser() {\n  $RefParser.apply(this, arguments);\n}\nutil.inherits(OpenAPIParser, $RefParser);\nOpenAPIParser.parse = $RefParser.parse;\nOpenAPIParser.resolve = $RefParser.resolve;\nOpenAPIParser.bundle = $RefParser.bundle;\nOpenAPIParser.dereference = $RefParser.dereference;\n\n/**\n * Alias {@link $RefParser#schema} as {@link OpenAPIParser#api}\n */\nObject.defineProperty(OpenAPIParser.prototype, 'api', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return this.schema;\n  }\n});\n\n/**\n * Parses the given Swagger API.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.prototype.parse = async function (path, api, options, callback) {\n  const args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n  try {\n    const schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);\n    if (schema.swagger) {\n      // Verify that the parsed object is a Swagger API\n      if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid Swagger API definition.`);\n      } else if (typeof schema.swagger === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Swagger version number must be a string (e.g. \"2.0\") not a number.');\n      } else if (typeof schema.info.version === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (schema.swagger !== '2.0') {\n        throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);\n      }\n    } else {\n      const supportedVersions = ['3.0.0', '3.0.1', '3.0.2', '3.0.3', '3.1.0'];\n\n      // Verify that the parsed object is an OpenAPI definition\n      if (schema.openapi === undefined || schema.info === undefined) {\n        throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n      } else if (schema.paths === undefined) {\n        if (schema.openapi === '3.1.0') {\n          if (schema.webhooks === undefined) {\n            throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n          }\n        } else {\n          throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n        }\n      } else if (typeof schema.openapi === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('OpenAPI version number must be a string (e.g. \"3.0.0\") not a number.');\n      } else if (typeof schema.info.version === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (supportedVersions.indexOf(schema.openapi) === -1) {\n        throw ono.syntax(`Unsupported OpenAPI version: ${schema.openapi}. ` + `Swagger Parser only supports versions ${supportedVersions.join(', ')}`);\n      }\n\n      // This is an OpenAPI v3 schema, check if the \"servers\" have any relative paths and\n      // fix them if the content was pulled from a web resource\n      util.fixOasRelativeServers(schema, args.path);\n    }\n\n    // Looks good!\n    return maybe(args.callback, Promise.resolve(schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.validate = function (path, api, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.validate.apply(instance, arguments);\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.prototype.validate = async function (path, api, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n  // (see https://github.com/zaggino/z-schema/issues/137)\n  const circular$RefOption = args.options.dereference.circular;\n  if (args.options.validate.schema) {\n    args.options.dereference.circular = 'ignore';\n  }\n  try {\n    await this.dereference(args.path, args.schema, args.options);\n\n    // Restore the original options, now that we're done dereferencing\n    args.options.dereference.circular = circular$RefOption;\n    if (args.options.validate.schema) {\n      // Validate the API against the Swagger schema\n      // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n      validateSchema(me.api, args.options);\n      if (me.$refs.circular) {\n        if (circular$RefOption === true) {\n          // The API has circular references,\n          // so we need to do a second-pass to fully-dereference it\n          dereference(me, args.options);\n        } else if (circular$RefOption === false) {\n          // The API has circular references, and they're not allowed, so throw an error\n          throw ono.reference('The API contains circular references');\n        }\n      }\n    }\n    if (args.options.validate.spec) {\n      // Validate the API against the Swagger spec\n      validateSpec(me.api);\n    }\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * The Swagger object\n * https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#swagger-object\n *\n * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject\n */","map":{"version":3,"names":["ono","require","$RefParser","dereference","normalizeArgs","maybe","Options","util","validateSchema","validateSpec","module","exports","OpenAPIParser","apply","arguments","inherits","parse","resolve","bundle","Object","defineProperty","prototype","configurable","enumerable","get","schema","path","api","options","callback","args","call","swagger","undefined","info","paths","syntax","version","supportedVersions","openapi","webhooks","indexOf","join","fixOasRelativeServers","Promise","err","reject","validate","Class","instance","me","circular$RefOption","circular","$refs","reference","spec"],"sources":["C:/Users/ryana/Desktop/CPSC 362 PROJECT/client/node_modules/@readme/openapi-parser/lib/index.js"],"sourcesContent":["/* eslint-disable no-unused-vars */\nconst { ono } = require('@jsdevtools/ono');\nconst $RefParser = require('@readme/json-schema-ref-parser');\nconst dereference = require('@readme/json-schema-ref-parser/lib/dereference');\nconst normalizeArgs = require('@readme/json-schema-ref-parser/lib/normalize-args');\nconst maybe = require('call-me-maybe');\n\nconst Options = require('./options');\nconst util = require('./util');\nconst validateSchema = require('./validators/schema');\nconst validateSpec = require('./validators/spec');\n\nmodule.exports = OpenAPIParser;\n\n/**\n * This class parses a Swagger 2.0 or 3.0 API, resolves its JSON references and their resolved values,\n * and provides methods for traversing, dereferencing, and validating the API.\n *\n * @class\n * @augments $RefParser\n */\nfunction OpenAPIParser() {\n  $RefParser.apply(this, arguments);\n}\n\nutil.inherits(OpenAPIParser, $RefParser);\nOpenAPIParser.parse = $RefParser.parse;\nOpenAPIParser.resolve = $RefParser.resolve;\nOpenAPIParser.bundle = $RefParser.bundle;\nOpenAPIParser.dereference = $RefParser.dereference;\n\n/**\n * Alias {@link $RefParser#schema} as {@link OpenAPIParser#api}\n */\nObject.defineProperty(OpenAPIParser.prototype, 'api', {\n  configurable: true,\n  enumerable: true,\n  get() {\n    return this.schema;\n  },\n});\n\n/**\n * Parses the given Swagger API.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.prototype.parse = async function (path, api, options, callback) {\n  const args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  try {\n    const schema = await $RefParser.prototype.parse.call(this, args.path, args.schema, args.options);\n\n    if (schema.swagger) {\n      // Verify that the parsed object is a Swagger API\n      if (schema.swagger === undefined || schema.info === undefined || schema.paths === undefined) {\n        throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid Swagger API definition.`);\n      } else if (typeof schema.swagger === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('Swagger version number must be a string (e.g. \"2.0\") not a number.');\n      } else if (typeof schema.info.version === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (schema.swagger !== '2.0') {\n        throw ono.syntax(`Unrecognized Swagger version: ${schema.swagger}. Expected 2.0`);\n      }\n    } else {\n      const supportedVersions = ['3.0.0', '3.0.1', '3.0.2', '3.0.3', '3.1.0'];\n\n      // Verify that the parsed object is an OpenAPI definition\n      if (schema.openapi === undefined || schema.info === undefined) {\n        throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n      } else if (schema.paths === undefined) {\n        if (schema.openapi === '3.1.0') {\n          if (schema.webhooks === undefined) {\n            throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n          }\n        } else {\n          throw ono.syntax(`${args.path || 'Supplied schema'} is not a valid OpenAPI definition.`);\n        }\n      } else if (typeof schema.openapi === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('OpenAPI version number must be a string (e.g. \"3.0.0\") not a number.');\n      } else if (typeof schema.info.version === 'number') {\n        // This is a very common mistake, so give a helpful error message\n        throw ono.syntax('API version number must be a string (e.g. \"1.0.0\") not a number.');\n      } else if (supportedVersions.indexOf(schema.openapi) === -1) {\n        throw ono.syntax(\n          `Unsupported OpenAPI version: ${schema.openapi}. ` +\n            `Swagger Parser only supports versions ${supportedVersions.join(', ')}`\n        );\n      }\n\n      // This is an OpenAPI v3 schema, check if the \"servers\" have any relative paths and\n      // fix them if the content was pulled from a web resource\n      util.fixOasRelativeServers(schema, args.path);\n    }\n\n    // Looks good!\n    return maybe(args.callback, Promise.resolve(schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.validate = function (path, api, options, callback) {\n  const Class = this;\n  const instance = new Class();\n  return instance.validate.apply(instance, arguments);\n};\n\n/**\n * Parses, dereferences, and validates the given Swagger API.\n * Depending on the options, validation can include JSON Schema validation and/or Swagger Spec validation.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [api] - The Swagger API object. This object will be used instead of reading from `path`.\n * @param {ParserOptions} [options] - Options that determine how the API is parsed, dereferenced, and validated\n * @param {Function} [callback] - An error-first callback. The second parameter is the parsed API object.\n * @returns {Promise} - The returned promise resolves with the parsed API object.\n */\nOpenAPIParser.prototype.validate = async function (path, api, options, callback) {\n  const me = this;\n  const args = normalizeArgs(arguments);\n  args.options = new Options(args.options);\n\n  // ZSchema doesn't support circular objects, so don't dereference circular $refs yet\n  // (see https://github.com/zaggino/z-schema/issues/137)\n  const circular$RefOption = args.options.dereference.circular;\n  if (args.options.validate.schema) {\n    args.options.dereference.circular = 'ignore';\n  }\n\n  try {\n    await this.dereference(args.path, args.schema, args.options);\n\n    // Restore the original options, now that we're done dereferencing\n    args.options.dereference.circular = circular$RefOption;\n\n    if (args.options.validate.schema) {\n      // Validate the API against the Swagger schema\n      // NOTE: This is safe to do, because we haven't dereferenced circular $refs yet\n      validateSchema(me.api, args.options);\n\n      if (me.$refs.circular) {\n        if (circular$RefOption === true) {\n          // The API has circular references,\n          // so we need to do a second-pass to fully-dereference it\n          dereference(me, args.options);\n        } else if (circular$RefOption === false) {\n          // The API has circular references, and they're not allowed, so throw an error\n          throw ono.reference('The API contains circular references');\n        }\n      }\n    }\n\n    if (args.options.validate.spec) {\n      // Validate the API against the Swagger spec\n      validateSpec(me.api);\n    }\n\n    return maybe(args.callback, Promise.resolve(me.schema));\n  } catch (err) {\n    return maybe(args.callback, Promise.reject(err));\n  }\n};\n\n/**\n * The Swagger object\n * https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#swagger-object\n *\n * @typedef {{swagger: string, info: {}, paths: {}}} SwaggerObject\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}